// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package resource_network_topology

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework-validators/int64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/listvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"regexp"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func NetworkTopologyResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"alarms": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"critical": schema.Int64Attribute{
						Optional: true,
						Computed: true,
					},
					"major": schema.Int64Attribute{
						Optional: true,
						Computed: true,
					},
					"minor": schema.Int64Attribute{
						Optional: true,
						Computed: true,
					},
					"warning": schema.Int64Attribute{
						Optional: true,
						Computed: true,
					},
				},
				CustomType: AlarmsType{
					ObjectType: types.ObjectType{
						AttrTypes: AlarmsValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
				Computed: true,
			},
			"api_version": schema.StringAttribute{
				Optional: true,
				Computed: true,
				Validators: []validator.String{
					stringvalidator.RegexMatches(regexp.MustCompile("^topologies\\.eda\\.nokia\\.com/v1alpha1$"), ""),
				},
				Default: stringdefault.StaticString("topologies.eda.nokia.com/v1alpha1"),
			},
			"deviations": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"count": schema.Int64Attribute{
						Optional: true,
						Computed: true,
					},
				},
				CustomType: DeviationsType{
					ObjectType: types.ObjectType{
						AttrTypes: DeviationsValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
				Computed: true,
			},
			"kind": schema.StringAttribute{
				Optional: true,
				Computed: true,
				Validators: []validator.String{
					stringvalidator.RegexMatches(regexp.MustCompile("^NetworkTopology$"), ""),
				},
				Default: stringdefault.StaticString("NetworkTopology"),
			},
			"metadata": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"annotations": schema.MapAttribute{
						ElementType: types.StringType,
						Optional:    true,
						Computed:    true,
					},
					"labels": schema.MapAttribute{
						ElementType: types.StringType,
						Optional:    true,
						Computed:    true,
					},
					"name": schema.StringAttribute{
						Required: true,
						Validators: []validator.String{
							stringvalidator.LengthAtMost(253),
							stringvalidator.RegexMatches(regexp.MustCompile("^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"), ""),
						},
					},
					"namespace": schema.StringAttribute{
						Required: true,
					},
				},
				CustomType: MetadataType{
					ObjectType: types.ObjectType{
						AttrTypes: MetadataValue{}.AttributeTypes(ctx),
					},
				},
				Required: true,
			},
			"name": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "name of the NetworkTopology",
				MarkdownDescription: "name of the NetworkTopology",
			},
			"namespace": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "the namespace scope in which to operate",
				MarkdownDescription: "the namespace scope in which to operate",
			},
			"spec": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"breakout_templates": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"annotations": schema.MapAttribute{
									ElementType:         types.StringType,
									Optional:            true,
									Description:         "Annotations to assign to the Breakout.",
									MarkdownDescription: "Annotations to assign to the Breakout.",
								},
								"channels": schema.Int64Attribute{
									Optional:            true,
									Description:         "The number of breakout channels to create",
									MarkdownDescription: "The number of breakout channels to create",
									Validators: []validator.Int64{
										int64validator.Between(1, 8),
									},
								},
								"labels": schema.MapAttribute{
									ElementType:         types.StringType,
									Optional:            true,
									Description:         "Labels to assign to the Breakout",
									MarkdownDescription: "Labels to assign to the Breakout",
								},
								"name": schema.StringAttribute{
									Required:            true,
									Description:         "The name of the BreakoutTemplate.",
									MarkdownDescription: "The name of the BreakoutTemplate.",
								},
								"speed": schema.StringAttribute{
									Optional:            true,
									Description:         "The speed of each breakout channel",
									MarkdownDescription: "The speed of each breakout channel",
									Validators: []validator.String{
										stringvalidator.OneOf(
											"800G",
											"400G",
											"200G",
											"100G",
											"50G",
											"40G",
											"25G",
											"10G",
										),
									},
								},
							},
							CustomType: BreakoutTemplatesType{
								ObjectType: types.ObjectType{
									AttrTypes: BreakoutTemplatesValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional:            true,
						Description:         "Define the breakout parameters that are meant to be inherited by the breakouts referencing the template. These parameters can be overridden at the breakout level.",
						MarkdownDescription: "Define the breakout parameters that are meant to be inherited by the breakouts referencing the template. These parameters can be overridden at the breakout level.",
					},
					"breakouts": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"annotations": schema.MapAttribute{
									ElementType:         types.StringType,
									Optional:            true,
									Description:         "Annotations to assign to the Breakouts.",
									MarkdownDescription: "Annotations to assign to the Breakouts.",
								},
								"channels": schema.Int64Attribute{
									Optional:            true,
									Description:         "The number of breakout channels to create",
									MarkdownDescription: "The number of breakout channels to create",
									Validators: []validator.Int64{
										int64validator.Between(1, 8),
									},
								},
								"interface": schema.ListAttribute{
									ElementType:         types.StringType,
									Required:            true,
									Description:         "A list of normalized parent interface/port",
									MarkdownDescription: "A list of normalized parent interface/port",
								},
								"labels": schema.MapAttribute{
									ElementType:         types.StringType,
									Optional:            true,
									Description:         "Labels to assign to the TopoBreakout",
									MarkdownDescription: "Labels to assign to the TopoBreakout",
								},
								"name": schema.StringAttribute{
									Required:            true,
									Description:         "The name of the TopoBreakout",
									MarkdownDescription: "The name of the TopoBreakout",
								},
								"node": schema.ListAttribute{
									ElementType:         types.StringType,
									Required:            true,
									Description:         "Reference to a list of TopoNodes where the parent interfaces are to be broken out",
									MarkdownDescription: "Reference to a list of TopoNodes where the parent interfaces are to be broken out",
								},
								"speed": schema.StringAttribute{
									Optional:            true,
									Description:         "The speed of each breakout channel",
									MarkdownDescription: "The speed of each breakout channel",
									Validators: []validator.String{
										stringvalidator.OneOf(
											"800G",
											"400G",
											"200G",
											"100G",
											"50G",
											"40G",
											"25G",
											"10G",
										),
									},
								},
								"template": schema.StringAttribute{
									Optional:            true,
									Description:         "Reference to a template to use for this TopoBreakout.",
									MarkdownDescription: "Reference to a template to use for this TopoBreakout.",
								},
							},
							CustomType: BreakoutsType{
								ObjectType: types.ObjectType{
									AttrTypes: BreakoutsValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional:            true,
						Description:         "Define the set of breakouts to be created/replaced/deleted. A breakout can reference a breakout template to inherit its parameters.",
						MarkdownDescription: "Define the set of breakouts to be created/replaced/deleted. A breakout can reference a breakout template to inherit its parameters.",
					},
					"checks": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"dry_run": schema.BoolAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "Enabling the Dry Run will run the transaction with the calculated changes to the topology resources in the dry run mode and pause the workflow awaiting users confirmation.",
								MarkdownDescription: "Enabling the Dry Run will run the transaction with the calculated changes to the topology resources in the dry run mode and pause the workflow awaiting users confirmation.",
								Default:             booldefault.StaticBool(false),
							},
							"prompt": schema.ListAttribute{
								ElementType:         types.StringType,
								Optional:            true,
								Description:         "Prompts can be configured to request user confirmation before creating, replacing, or deleting topology resources, regardless if Dry Run is enabled or not.\nThis can be configured per operation type (BeforeCreate, BeforeReplace, BeforeDelete).",
								MarkdownDescription: "Prompts can be configured to request user confirmation before creating, replacing, or deleting topology resources, regardless if Dry Run is enabled or not.\nThis can be configured per operation type (BeforeCreate, BeforeReplace, BeforeDelete).",
							},
						},
						CustomType: ChecksType{
							ObjectType: types.ObjectType{
								AttrTypes: ChecksValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Description:         "Configure dry run mode and prompts for topology operations.",
						MarkdownDescription: "Configure dry run mode and prompts for topology operations.",
					},
					"link_templates": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"annotations": schema.MapAttribute{
									ElementType:         types.StringType,
									Optional:            true,
									Description:         "Annotations to assign to the TopoLink.",
									MarkdownDescription: "Annotations to assign to the TopoLink.",
								},
								"encap_type": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "Enable or disable VLAN tagging on Interfaces created by the TopoLink.",
									MarkdownDescription: "Enable or disable VLAN tagging on Interfaces created by the TopoLink.",
									Validators: []validator.String{
										stringvalidator.OneOf(
											"null",
											"dot1q",
										),
									},
									Default: stringdefault.StaticString("null"),
								},
								"labels": schema.MapAttribute{
									ElementType:         types.StringType,
									Optional:            true,
									Description:         "Labels to assign to the TopoLink.",
									MarkdownDescription: "Labels to assign to the TopoLink.",
								},
								"name": schema.StringAttribute{
									Required:            true,
									Description:         "The name of the TopoLinkTemplate.",
									MarkdownDescription: "The name of the TopoLinkTemplate.",
								},
								"speed": schema.StringAttribute{
									Optional:            true,
									Description:         "Speed of the link.",
									MarkdownDescription: "Speed of the link.",
									Validators: []validator.String{
										stringvalidator.OneOf(
											"800G",
											"400G",
											"200G",
											"100G",
											"50G",
											"40G",
											"25G",
											"10G",
											"2.5G",
											"1G",
											"100M",
										),
									},
								},
								"type": schema.StringAttribute{
									Optional:            true,
									Description:         "Specify the type of link.\nIf type is set to edge, topology information for the remote device can be set; when doing so the Remote Node can be set as the hostname of the remote device and Remote Interface as the remote interface name in the device specific format, e.g. eth0.",
									MarkdownDescription: "Specify the type of link.\nIf type is set to edge, topology information for the remote device can be set; when doing so the Remote Node can be set as the hostname of the remote device and Remote Interface as the remote interface name in the device specific format, e.g. eth0.",
									Validators: []validator.String{
										stringvalidator.OneOf(
											"edge",
											"interSwitch",
											"loopback",
										),
									},
								},
							},
							CustomType: LinkTemplatesType{
								ObjectType: types.ObjectType{
									AttrTypes: LinkTemplatesValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional:            true,
						Description:         "Define the link parameters that are meant to be inherited by the topology links referencing the template. These parameters can be overridden at the link level.",
						MarkdownDescription: "Define the link parameters that are meant to be inherited by the topology links referencing the template. These parameters can be overridden at the link level.",
					},
					"links": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"annotations": schema.MapAttribute{
									ElementType:         types.StringType,
									Optional:            true,
									Description:         "Annotations to assign to the TopoLink.",
									MarkdownDescription: "Annotations to assign to the TopoLink.",
								},
								"encap_type": schema.StringAttribute{
									Optional:            true,
									Description:         "Enable or disable VLAN tagging on Interfaces created by the TopoLink",
									MarkdownDescription: "Enable or disable VLAN tagging on Interfaces created by the TopoLink",
									Validators: []validator.String{
										stringvalidator.OneOf(
											"null",
											"dot1q",
										),
									},
								},
								"endpoints": schema.ListNestedAttribute{
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"local": schema.SingleNestedAttribute{
												Attributes: map[string]schema.Attribute{
													"interface": schema.StringAttribute{
														Optional:            true,
														Description:         "Normalized name of the interface/port, e.g. ethernet-1-1.",
														MarkdownDescription: "Normalized name of the interface/port, e.g. ethernet-1-1.",
													},
													"interface_resource": schema.StringAttribute{
														Optional:            true,
														Description:         "Reference to a Interface.",
														MarkdownDescription: "Reference to a Interface.",
													},
													"node": schema.StringAttribute{
														Required:            true,
														Description:         "Reference to a TopoNode.",
														MarkdownDescription: "Reference to a TopoNode.",
													},
												},
												CustomType: LocalType{
													ObjectType: types.ObjectType{
														AttrTypes: LocalValue{}.AttributeTypes(ctx),
													},
												},
												Required:            true,
												Description:         "Local, or \"A\" endpoint of the link.",
												MarkdownDescription: "Local, or \"A\" endpoint of the link.",
											},
											"remote": schema.SingleNestedAttribute{
												Attributes: map[string]schema.Attribute{
													"interface": schema.StringAttribute{
														Optional:            true,
														Description:         "Normalized name of the interface/port, e.g. ethernet-1-1.",
														MarkdownDescription: "Normalized name of the interface/port, e.g. ethernet-1-1.",
													},
													"interface_resource": schema.StringAttribute{
														Optional:            true,
														Description:         "Reference to a Interface.",
														MarkdownDescription: "Reference to a Interface.",
													},
													"node": schema.StringAttribute{
														Required:            true,
														Description:         "Reference to a TopoNode.",
														MarkdownDescription: "Reference to a TopoNode.",
													},
												},
												CustomType: RemoteType{
													ObjectType: types.ObjectType{
														AttrTypes: RemoteValue{}.AttributeTypes(ctx),
													},
												},
												Optional:            true,
												Description:         "Remote, or \"B\" endpoint of the link.",
												MarkdownDescription: "Remote, or \"B\" endpoint of the link.",
											},
											"sim": schema.SingleNestedAttribute{
												Attributes: map[string]schema.Attribute{
													"sim_node": schema.StringAttribute{
														Optional:            true,
														Description:         "The SimNode to which the interface will be mapped. This is the name of the SimNode as it is defined in the SimTopology.",
														MarkdownDescription: "The SimNode to which the interface will be mapped. This is the name of the SimNode as it is defined in the SimTopology.",
													},
													"sim_node_interface": schema.StringAttribute{
														Optional:            true,
														Description:         "The name of the interface to present to the SimNode to which the interface will be mapped. If not provided the interface name will be generated starting with \"eth1\", \"eth2\", ... .\nThis is the interface name as it will appear in the SimNode.",
														MarkdownDescription: "The name of the interface to present to the SimNode to which the interface will be mapped. If not provided the interface name will be generated starting with \"eth1\", \"eth2\", ... .\nThis is the interface name as it will appear in the SimNode.",
													},
												},
												CustomType: SimType{
													ObjectType: types.ObjectType{
														AttrTypes: SimValue{}.AttributeTypes(ctx),
													},
												},
												Optional:            true,
												Description:         "Sim endpoint of the link.",
												MarkdownDescription: "Sim endpoint of the link.",
											},
											"speed": schema.StringAttribute{
												Optional:            true,
												Description:         "Speed of the link.",
												MarkdownDescription: "Speed of the link.",
												Validators: []validator.String{
													stringvalidator.OneOf(
														"800G",
														"400G",
														"200G",
														"100G",
														"50G",
														"40G",
														"25G",
														"10G",
														"2.5G",
														"1G",
														"100M",
													),
												},
											},
											"type": schema.StringAttribute{
												Optional:            true,
												Description:         "Specify the type of link.\nIf type is set to edge, topology information for the remote device can be set; when doing so the Remote Node can be set as the hostname of the remote device and Remote Interface as the remote interface name in the device specific format, e.g. eth0.",
												MarkdownDescription: "Specify the type of link.\nIf type is set to edge, topology information for the remote device can be set; when doing so the Remote Node can be set as the hostname of the remote device and Remote Interface as the remote interface name in the device specific format, e.g. eth0.",
												Validators: []validator.String{
													stringvalidator.OneOf(
														"edge",
														"interSwitch",
														"loopback",
													),
												},
											},
										},
										CustomType: EndpointsType{
											ObjectType: types.ObjectType{
												AttrTypes: EndpointsValue{}.AttributeTypes(ctx),
											},
										},
									},
									Required:            true,
									Description:         "Define the set of physical links making up this TopoLink.",
									MarkdownDescription: "Define the set of physical links making up this TopoLink.",
									Validators: []validator.List{
										listvalidator.SizeAtLeast(1),
									},
								},
								"labels": schema.MapAttribute{
									ElementType:         types.StringType,
									Optional:            true,
									Description:         "Labels to assign to the TopoLink",
									MarkdownDescription: "Labels to assign to the TopoLink",
								},
								"name": schema.StringAttribute{
									Required:            true,
									Description:         "The name of the TopoLink",
									MarkdownDescription: "The name of the TopoLink",
								},
								"template": schema.StringAttribute{
									Optional:            true,
									Description:         "Reference to a template to use for this TopoLink.",
									MarkdownDescription: "Reference to a template to use for this TopoLink.",
								},
							},
							CustomType: LinksType{
								ObjectType: types.ObjectType{
									AttrTypes: LinksValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional:            true,
						Description:         "Define the set of topology links to be created/replaced/deleted. A link can reference a link template to inherit its parameters.",
						MarkdownDescription: "Define the set of topology links to be created/replaced/deleted. A link can reference a link template to inherit its parameters.",
					},
					"node_templates": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"annotations": schema.MapAttribute{
									ElementType:         types.StringType,
									Optional:            true,
									Description:         "Annotations to assign to the TopoNode.",
									MarkdownDescription: "Annotations to assign to the TopoNode.",
								},
								"component": schema.ListNestedAttribute{
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"kind": schema.StringAttribute{
												Required:            true,
												Description:         "The kind of Component, e.g. lineCard.",
												MarkdownDescription: "The kind of Component, e.g. lineCard.",
												Validators: []validator.String{
													stringvalidator.OneOf(
														"controlCard",
														"lineCard",
														"fabric",
														"mda",
														"connector",
														"xiom",
														"powerShelf",
														"powerModule",
													),
												},
											},
											"slot": schema.StringAttribute{
												Optional:            true,
												Description:         "The slot this Component resides in, unset for Components that do not have a slot or ID.\ne.g. 1 would denote the linecard slot 1, 1/1 would denote linecard slot 1 mda slot 1.",
												MarkdownDescription: "The slot this Component resides in, unset for Components that do not have a slot or ID.\ne.g. 1 would denote the linecard slot 1, 1/1 would denote linecard slot 1 mda slot 1.",
											},
											"type": schema.StringAttribute{
												Required:            true,
												Description:         "Denotes the type of hardware being provisioned, e.g. xcm-x20.",
												MarkdownDescription: "Denotes the type of hardware being provisioned, e.g. xcm-x20.",
											},
										},
										CustomType: ComponentType{
											ObjectType: types.ObjectType{
												AttrTypes: ComponentValue{}.AttributeTypes(ctx),
											},
										},
									},
									Optional:            true,
									Description:         "List of components within the TopoNode.\nUsed to define the type and location of linecards, fabrics (SFM), media adapter cards (MDA) and control cards (CPM).",
									MarkdownDescription: "List of components within the TopoNode.\nUsed to define the type and location of linecards, fabrics (SFM), media adapter cards (MDA) and control cards (CPM).",
								},
								"labels": schema.MapAttribute{
									ElementType:         types.StringType,
									Optional:            true,
									Description:         "Labels to assign to the TopoNode.",
									MarkdownDescription: "Labels to assign to the TopoNode.",
								},
								"license": schema.StringAttribute{
									Optional:            true,
									Description:         "Reference to a ConfigMap containing a license for the TopoNode. Overrides the license set in the referenced NodeProfile, if present.",
									MarkdownDescription: "Reference to a ConfigMap containing a license for the TopoNode. Overrides the license set in the referenced NodeProfile, if present.",
								},
								"name": schema.StringAttribute{
									Required:            true,
									Description:         "The name of the TopoNodeTemplate.",
									MarkdownDescription: "The name of the TopoNodeTemplate.",
								},
								"node_profile": schema.StringAttribute{
									Optional:            true,
									Description:         "Reference to a NodeProfile to use with this TopoNode.",
									MarkdownDescription: "Reference to a NodeProfile to use with this TopoNode.",
								},
								"platform": schema.StringAttribute{
									Optional:            true,
									Description:         "Platform type of this TopoNode, e.g. 7220 IXR-D3L.",
									MarkdownDescription: "Platform type of this TopoNode, e.g. 7220 IXR-D3L.",
								},
							},
							CustomType: NodeTemplatesType{
								ObjectType: types.ObjectType{
									AttrTypes: NodeTemplatesValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional:            true,
						Description:         "Define the node parameters that are meant to be inherited by the topology nodes referencing the template. These parameters can be overridden at the node level.",
						MarkdownDescription: "Define the node parameters that are meant to be inherited by the topology nodes referencing the template. These parameters can be overridden at the node level.",
					},
					"nodes": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"annotations": schema.MapAttribute{
									ElementType:         types.StringType,
									Optional:            true,
									Description:         "Annotations to assign to the TopoNode.",
									MarkdownDescription: "Annotations to assign to the TopoNode.",
								},
								"component": schema.ListNestedAttribute{
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"kind": schema.StringAttribute{
												Required:            true,
												Description:         "The kind of Component, e.g. lineCard.",
												MarkdownDescription: "The kind of Component, e.g. lineCard.",
												Validators: []validator.String{
													stringvalidator.OneOf(
														"controlCard",
														"lineCard",
														"fabric",
														"mda",
														"connector",
														"xiom",
														"powerShelf",
														"powerModule",
													),
												},
											},
											"slot": schema.StringAttribute{
												Optional:            true,
												Description:         "The slot this Component resides in, unset for Components that do not have a slot or ID.\ne.g. 1 would denote the linecard slot 1, 1/1 would denote linecard slot 1 mda slot 1.",
												MarkdownDescription: "The slot this Component resides in, unset for Components that do not have a slot or ID.\ne.g. 1 would denote the linecard slot 1, 1/1 would denote linecard slot 1 mda slot 1.",
											},
											"type": schema.StringAttribute{
												Required:            true,
												Description:         "Denotes the type of hardware being provisioned, e.g. xcm-x20.",
												MarkdownDescription: "Denotes the type of hardware being provisioned, e.g. xcm-x20.",
											},
										},
										CustomType: Component1Type{
											ObjectType: types.ObjectType{
												AttrTypes: Component1Value{}.AttributeTypes(ctx),
											},
										},
									},
									Optional:            true,
									Description:         "List of components within the TopoNode.\nUsed to define the type and location of linecards, fabrics (SFM), media adapter cards (MDA) and control cards (CPM).",
									MarkdownDescription: "List of components within the TopoNode.\nUsed to define the type and location of linecards, fabrics (SFM), media adapter cards (MDA) and control cards (CPM).",
								},
								"labels": schema.MapAttribute{
									ElementType:         types.StringType,
									Optional:            true,
									Description:         "Labels to assign to the TopoNode",
									MarkdownDescription: "Labels to assign to the TopoNode",
								},
								"license": schema.StringAttribute{
									Optional:            true,
									Description:         "Reference to a ConfigMap containing a license for the TopoNode. Overrides the license set in the referenced NodeProfile, if present.",
									MarkdownDescription: "Reference to a ConfigMap containing a license for the TopoNode. Overrides the license set in the referenced NodeProfile, if present.",
								},
								"mac_address": schema.StringAttribute{
									Optional:            true,
									Description:         "MAC address to associate with this TopoNode.\nTypically the chassis MAC address, optionally sent by a node in DHCP requests.\nNot required when a TopoNode is not being bootstrapped by EDA, or is simulated through CX.",
									MarkdownDescription: "MAC address to associate with this TopoNode.\nTypically the chassis MAC address, optionally sent by a node in DHCP requests.\nNot required when a TopoNode is not being bootstrapped by EDA, or is simulated through CX.",
								},
								"name": schema.StringAttribute{
									Required:            true,
									Description:         "The name of the TopoNode",
									MarkdownDescription: "The name of the TopoNode",
								},
								"node_profile": schema.StringAttribute{
									Optional:            true,
									Description:         "Reference to a NodeProfile to use with this TopoNode.",
									MarkdownDescription: "Reference to a NodeProfile to use with this TopoNode.",
								},
								"npp": schema.SingleNestedAttribute{
									Attributes: map[string]schema.Attribute{
										"mode": schema.StringAttribute{
											Optional:            true,
											Computed:            true,
											Description:         "The mode in which this TopoNode is functioning.\n\"normal\" (the default)\n   indicates that NPP is expecting an endpoint to exist, and will accept and confirm changes only if the endpoint\n   accepts them.\n\"maintenance\"\n   indicates that no changes will be accepted for the TopoNode, irrespective if the endpoint is up and reachable.\n   The exception is if an upgrade is occuring, in which case changes will be accepted.\n\"null\"\n\t  indicates that changes will be accepted from CRs and no NPP will be spun up. NPP validation will not occur.\n   This may be useful in playground mode to avoid spinning up of 1000s of NPPs.\n\"emulate\"\n   indicates that changes will be accepted at the NPP level, without pushing them to a endpoint. NPP validation\n   still occurs.  If no IP address is present, we also run in emulate mode.\n\"monitor\"\n   indicates that state will be collectd but config will not be pushed to a endpoint. NPP validation still occurs.",
											MarkdownDescription: "The mode in which this TopoNode is functioning.\n\"normal\" (the default)\n   indicates that NPP is expecting an endpoint to exist, and will accept and confirm changes only if the endpoint\n   accepts them.\n\"maintenance\"\n   indicates that no changes will be accepted for the TopoNode, irrespective if the endpoint is up and reachable.\n   The exception is if an upgrade is occuring, in which case changes will be accepted.\n\"null\"\n\t  indicates that changes will be accepted from CRs and no NPP will be spun up. NPP validation will not occur.\n   This may be useful in playground mode to avoid spinning up of 1000s of NPPs.\n\"emulate\"\n   indicates that changes will be accepted at the NPP level, without pushing them to a endpoint. NPP validation\n   still occurs.  If no IP address is present, we also run in emulate mode.\n\"monitor\"\n   indicates that state will be collectd but config will not be pushed to a endpoint. NPP validation still occurs.",
											Validators: []validator.String{
												stringvalidator.OneOf(
													"normal",
													"maintenance",
													"null",
													"emulate",
													"monitor",
												),
											},
											Default: stringdefault.StaticString("normal"),
										},
									},
									CustomType: NppType{
										ObjectType: types.ObjectType{
											AttrTypes: NppValue{}.AttributeTypes(ctx),
										},
									},
									Optional:            true,
									Description:         "Options relating to NPP interactions with the node.",
									MarkdownDescription: "Options relating to NPP interactions with the node.",
								},
								"on_boarded": schema.BoolAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "Indicates if this TopoNode has been bootstrapped or is reachable via configured credentials. Set by BootstrapServer when it completes onboarding functions for a given TopoNode.\nMost applications ignore TopoNodes that have not been onboarded yet.",
									MarkdownDescription: "Indicates if this TopoNode has been bootstrapped or is reachable via configured credentials. Set by BootstrapServer when it completes onboarding functions for a given TopoNode.\nMost applications ignore TopoNodes that have not been onboarded yet.",
									Default:             booldefault.StaticBool(false),
								},
								"operating_system": schema.StringAttribute{
									Optional:            true,
									Description:         "Operating system running on this TopoNode, e.g. srl.",
									MarkdownDescription: "Operating system running on this TopoNode, e.g. srl.",
									Validators: []validator.String{
										stringvalidator.OneOf(
											"srl",
											"sros",
											"eos",
											"sonic",
											"ios-xr",
											"nxos",
											"linux",
										),
									},
								},
								"platform": schema.StringAttribute{
									Optional:            true,
									Description:         "Platform type of this TopoNode, e.g. 7220 IXR-D3L.",
									MarkdownDescription: "Platform type of this TopoNode, e.g. 7220 IXR-D3L.",
								},
								"production_address": schema.SingleNestedAttribute{
									Attributes: map[string]schema.Attribute{
										"ipv4": schema.StringAttribute{
											Optional:            true,
											Description:         "The IPv4 production address",
											MarkdownDescription: "The IPv4 production address",
										},
										"ipv6": schema.StringAttribute{
											Optional:            true,
											Description:         "The IPv6 production address",
											MarkdownDescription: "The IPv6 production address",
										},
									},
									CustomType: ProductionAddressType{
										ObjectType: types.ObjectType{
											AttrTypes: ProductionAddressValue{}.AttributeTypes(ctx),
										},
									},
									Optional:            true,
									Description:         "Production address of this TopoNode - this is the address the real, production instance of this TopoNode uses.\nIf left blank, an address will be allocated from the management IP pool specified in the referenced NodeProfile.\nIf this TopoNode is not bootstrapped by EDA this field must be provided.",
									MarkdownDescription: "Production address of this TopoNode - this is the address the real, production instance of this TopoNode uses.\nIf left blank, an address will be allocated from the management IP pool specified in the referenced NodeProfile.\nIf this TopoNode is not bootstrapped by EDA this field must be provided.",
								},
								"serial_number": schema.StringAttribute{
									Optional:            true,
									Description:         "Serial number of this TopoNode, optionally sent by a node in DHCP requests.\nNot required when a TopoNode is not being bootstrapped by EDA, or is simulated through CX.",
									MarkdownDescription: "Serial number of this TopoNode, optionally sent by a node in DHCP requests.\nNot required when a TopoNode is not being bootstrapped by EDA, or is simulated through CX.",
								},
								"system_interface": schema.StringAttribute{
									Optional:            true,
									Description:         "Deprecated: Name of the Interface resource representing the primary loopback on the TopoNode, this field will be removed in the future version.",
									MarkdownDescription: "Deprecated: Name of the Interface resource representing the primary loopback on the TopoNode, this field will be removed in the future version.",
								},
								"template": schema.StringAttribute{
									Optional:            true,
									Description:         "Reference to a template to use for this TopoNode.",
									MarkdownDescription: "Reference to a template to use for this TopoNode.",
								},
								"version": schema.StringAttribute{
									Optional:            true,
									Description:         "Sets the software version of this TopoNode, e.g. 24.7.1 (for srl), or 24.7.r1 (for sros).",
									MarkdownDescription: "Sets the software version of this TopoNode, e.g. 24.7.1 (for srl), or 24.7.r1 (for sros).",
								},
							},
							CustomType: NodesType{
								ObjectType: types.ObjectType{
									AttrTypes: NodesValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional:            true,
						Description:         "Define the set of topology nodes to be created/replaced/deleted. A node can reference a node template to inherit its parameters.",
						MarkdownDescription: "Define the set of topology nodes to be created/replaced/deleted. A node can reference a node template to inherit its parameters.",
					},
					"operation": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Operation to be performed on the Topology.\nCreate - creates the topology resources based on the provided specifications.\nReplace - replaces the resources matched by name with the provided specifications.\nReplaceAll - first removes all existing topology resources and then creates new ones based on the provided specifications.\nDelete - deletes the resources matched by name.\nDeleteAll - deletes all topology resources found in the namespace.\nOne of create, replace, replaceAll, delete, deleteAll.",
						MarkdownDescription: "Operation to be performed on the Topology.\nCreate - creates the topology resources based on the provided specifications.\nReplace - replaces the resources matched by name with the provided specifications.\nReplaceAll - first removes all existing topology resources and then creates new ones based on the provided specifications.\nDelete - deletes the resources matched by name.\nDeleteAll - deletes all topology resources found in the namespace.\nOne of create, replace, replaceAll, delete, deleteAll.",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"create",
								"replace",
								"replaceAll",
								"delete",
								"deleteAll",
							),
						},
						Default: stringdefault.StaticString("create"),
					},
					"remote_location": schema.StringAttribute{
						Optional:            true,
						Description:         "http(s) location of the topology input in YAML format to deploy. Providing the remote location will discard any topology resources provided in the spec of the workflow.",
						MarkdownDescription: "http(s) location of the topology input in YAML format to deploy. Providing the remote location will discard any topology resources provided in the spec of the workflow.",
					},
					"simulation": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"sim_node_templates": schema.ListNestedAttribute{
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"image": schema.StringAttribute{
											Optional:            true,
											Description:         "The image to use for this SimNode. This is the full path to the image as it would be provided to the container runtime.",
											MarkdownDescription: "The image to use for this SimNode. This is the full path to the image as it would be provided to the container runtime.",
										},
										"image_pull_secret": schema.StringAttribute{
											Optional:            true,
											Description:         "Reference to a Secret to use when pulling the image for this simNode.",
											MarkdownDescription: "Reference to a Secret to use when pulling the image for this simNode.",
										},
										"name": schema.StringAttribute{
											Required:            true,
											Description:         "The name of the template.",
											MarkdownDescription: "The name of the template.",
										},
										"type": schema.StringAttribute{
											Optional:            true,
											Description:         "Type defines what is type of this SimNode.",
											MarkdownDescription: "Type defines what is type of this SimNode.",
											Validators: []validator.String{
												stringvalidator.OneOf(
													"Linux",
													"TestMan",
													"SrlTest",
												),
											},
										},
									},
									CustomType: SimNodeTemplatesType{
										ObjectType: types.ObjectType{
											AttrTypes: SimNodeTemplatesValue{}.AttributeTypes(ctx),
										},
									},
								},
								Optional:            true,
								Description:         "Define the simulation node (sim node) parameters that are meant to be inherited by the simulation nodes referencing the template. These parameters can be overridden at the sim node level.",
								MarkdownDescription: "Define the simulation node (sim node) parameters that are meant to be inherited by the simulation nodes referencing the template. These parameters can be overridden at the sim node level.",
							},
							"sim_nodes": schema.ListNestedAttribute{
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"image": schema.StringAttribute{
											Optional:            true,
											Description:         "The image to use for this SimNode. This is the full path to the image as it would be provided to the container runtime.",
											MarkdownDescription: "The image to use for this SimNode. This is the full path to the image as it would be provided to the container runtime.",
										},
										"image_pull_secret": schema.StringAttribute{
											Optional:            true,
											Description:         "Reference to a Secret to use when pulling the image for this simNode",
											MarkdownDescription: "Reference to a Secret to use when pulling the image for this simNode",
										},
										"name": schema.StringAttribute{
											Required:            true,
											Description:         "The name of the SimNode. This is the name that will be used to reference the SimNode in the SimTopology.",
											MarkdownDescription: "The name of the SimNode. This is the name that will be used to reference the SimNode in the SimTopology.",
										},
										"template": schema.StringAttribute{
											Optional:            true,
											Description:         "Reference to a template to use for this SimNode.",
											MarkdownDescription: "Reference to a template to use for this SimNode.",
										},
										"type": schema.StringAttribute{
											Optional:            true,
											Description:         "Type defines what is type of this SimNode",
											MarkdownDescription: "Type defines what is type of this SimNode",
											Validators: []validator.String{
												stringvalidator.OneOf(
													"Linux",
													"TestMan",
													"SrlTest",
												),
											},
										},
									},
									CustomType: SimNodesType{
										ObjectType: types.ObjectType{
											AttrTypes: SimNodesValue{}.AttributeTypes(ctx),
										},
									},
								},
								Optional:            true,
								Description:         "Define the sim node to be created/replaced/deleted. A sim node can reference a sim node template to inherit its parameters.",
								MarkdownDescription: "Define the sim node to be created/replaced/deleted. A sim node can reference a sim node template to inherit its parameters.",
							},
							"topology": schema.ListNestedAttribute{
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"interface": schema.StringAttribute{
											Required:            true,
											Description:         "Normalized name of an interface/port. This is the normalized name of the interface in the TopoNode, for example 'ethernet-1-1'.\nThe value of \"*\" indicates all interfaces on the TopoNode/s.",
											MarkdownDescription: "Normalized name of an interface/port. This is the normalized name of the interface in the TopoNode, for example 'ethernet-1-1'.\nThe value of \"*\" indicates all interfaces on the TopoNode/s.",
										},
										"node": schema.StringAttribute{
											Required:            true,
											Description:         "The TopoNode on which interfaces will be mapped to a SimNode. You may use the value \"*\" to indicate all TopoNodes.",
											MarkdownDescription: "The TopoNode on which interfaces will be mapped to a SimNode. You may use the value \"*\" to indicate all TopoNodes.",
										},
										"sim_node": schema.StringAttribute{
											Required:            true,
											Description:         "The SimNode to which the interface will be mapped. This is the name of the SimNode as it is defined in the SimTopology.",
											MarkdownDescription: "The SimNode to which the interface will be mapped. This is the name of the SimNode as it is defined in the SimTopology.",
										},
										"sim_node_interface": schema.StringAttribute{
											Optional:            true,
											Description:         "The name of the interface to present to the SimNode to which the interface will be mapped. If not provided the interface name will be generated starting with \"eth1\", \"eth2\",...\nThis is the interface name as it will appear in the SimNode.",
											MarkdownDescription: "The name of the interface to present to the SimNode to which the interface will be mapped. If not provided the interface name will be generated starting with \"eth1\", \"eth2\",...\nThis is the interface name as it will appear in the SimNode.",
										},
									},
									CustomType: TopologyType{
										ObjectType: types.ObjectType{
											AttrTypes: TopologyValue{}.AttributeTypes(ctx),
										},
									},
								},
								Optional:            true,
								Description:         "Define the simulation topology to be created/replaced/deleted by providing the list of nodes/interfaces and their corresponding sim nodes/sim node interfaces.",
								MarkdownDescription: "Define the simulation topology to be created/replaced/deleted by providing the list of nodes/interfaces and their corresponding sim nodes/sim node interfaces.",
							},
						},
						CustomType: SimulationType{
							ObjectType: types.ObjectType{
								AttrTypes: SimulationValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Description:         "Specify simulation topology configuration.",
						MarkdownDescription: "Specify simulation topology configuration.",
					},
				},
				CustomType: SpecType{
					ObjectType: types.ObjectType{
						AttrTypes: SpecValue{}.AttributeTypes(ctx),
					},
				},
				Required: true,
			},
			"status": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"message": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Human-readable message providing additional context about the operation result",
						MarkdownDescription: "Human-readable message providing additional context about the operation result",
					},
					"processed": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"breakouts": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"created": schema.Int64Attribute{
										Optional:            true,
										Computed:            true,
										Description:         "Number of resources created",
										MarkdownDescription: "Number of resources created",
									},
									"deleted": schema.Int64Attribute{
										Optional:            true,
										Computed:            true,
										Description:         "Number of resources deleted",
										MarkdownDescription: "Number of resources deleted",
									},
									"updated": schema.Int64Attribute{
										Optional:            true,
										Computed:            true,
										Description:         "Number of resources updated",
										MarkdownDescription: "Number of resources updated",
									},
								},
								CustomType: Breakouts1Type{
									ObjectType: types.ObjectType{
										AttrTypes: Breakouts1Value{}.AttributeTypes(ctx),
									},
								},
								Optional:            true,
								Computed:            true,
								Description:         "Summary of breakout operations",
								MarkdownDescription: "Summary of breakout operations",
							},
							"interfaces": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"created": schema.Int64Attribute{
										Optional:            true,
										Computed:            true,
										Description:         "Number of resources created",
										MarkdownDescription: "Number of resources created",
									},
									"deleted": schema.Int64Attribute{
										Optional:            true,
										Computed:            true,
										Description:         "Number of resources deleted",
										MarkdownDescription: "Number of resources deleted",
									},
									"updated": schema.Int64Attribute{
										Optional:            true,
										Computed:            true,
										Description:         "Number of resources updated",
										MarkdownDescription: "Number of resources updated",
									},
								},
								CustomType: InterfacesType{
									ObjectType: types.ObjectType{
										AttrTypes: InterfacesValue{}.AttributeTypes(ctx),
									},
								},
								Optional:            true,
								Computed:            true,
								Description:         "Summary of interface operations",
								MarkdownDescription: "Summary of interface operations",
							},
							"links": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"created": schema.Int64Attribute{
										Optional:            true,
										Computed:            true,
										Description:         "Number of resources created",
										MarkdownDescription: "Number of resources created",
									},
									"deleted": schema.Int64Attribute{
										Optional:            true,
										Computed:            true,
										Description:         "Number of resources deleted",
										MarkdownDescription: "Number of resources deleted",
									},
									"updated": schema.Int64Attribute{
										Optional:            true,
										Computed:            true,
										Description:         "Number of resources updated",
										MarkdownDescription: "Number of resources updated",
									},
								},
								CustomType: Links1Type{
									ObjectType: types.ObjectType{
										AttrTypes: Links1Value{}.AttributeTypes(ctx),
									},
								},
								Optional:            true,
								Computed:            true,
								Description:         "Summary of link operations",
								MarkdownDescription: "Summary of link operations",
							},
							"nodes": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"created": schema.Int64Attribute{
										Optional:            true,
										Computed:            true,
										Description:         "Number of resources created",
										MarkdownDescription: "Number of resources created",
									},
									"deleted": schema.Int64Attribute{
										Optional:            true,
										Computed:            true,
										Description:         "Number of resources deleted",
										MarkdownDescription: "Number of resources deleted",
									},
									"updated": schema.Int64Attribute{
										Optional:            true,
										Computed:            true,
										Description:         "Number of resources updated",
										MarkdownDescription: "Number of resources updated",
									},
								},
								CustomType: Nodes1Type{
									ObjectType: types.ObjectType{
										AttrTypes: Nodes1Value{}.AttributeTypes(ctx),
									},
								},
								Optional:            true,
								Computed:            true,
								Description:         "Summary of node operations",
								MarkdownDescription: "Summary of node operations",
							},
							"sim_links": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"created": schema.Int64Attribute{
										Optional:            true,
										Computed:            true,
										Description:         "Number of resources created",
										MarkdownDescription: "Number of resources created",
									},
									"deleted": schema.Int64Attribute{
										Optional:            true,
										Computed:            true,
										Description:         "Number of resources deleted",
										MarkdownDescription: "Number of resources deleted",
									},
									"updated": schema.Int64Attribute{
										Optional:            true,
										Computed:            true,
										Description:         "Number of resources updated",
										MarkdownDescription: "Number of resources updated",
									},
								},
								CustomType: SimLinksType{
									ObjectType: types.ObjectType{
										AttrTypes: SimLinksValue{}.AttributeTypes(ctx),
									},
								},
								Optional:            true,
								Computed:            true,
								Description:         "Summary of simulation link operations",
								MarkdownDescription: "Summary of simulation link operations",
							},
							"sim_nodes": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"created": schema.Int64Attribute{
										Optional:            true,
										Computed:            true,
										Description:         "Number of resources created",
										MarkdownDescription: "Number of resources created",
									},
									"deleted": schema.Int64Attribute{
										Optional:            true,
										Computed:            true,
										Description:         "Number of resources deleted",
										MarkdownDescription: "Number of resources deleted",
									},
									"updated": schema.Int64Attribute{
										Optional:            true,
										Computed:            true,
										Description:         "Number of resources updated",
										MarkdownDescription: "Number of resources updated",
									},
								},
								CustomType: SimNodes1Type{
									ObjectType: types.ObjectType{
										AttrTypes: SimNodes1Value{}.AttributeTypes(ctx),
									},
								},
								Optional:            true,
								Computed:            true,
								Description:         "Summary of simulation node operations",
								MarkdownDescription: "Summary of simulation node operations",
							},
							"total_duration": schema.StringAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "Total duration of the topology operation",
								MarkdownDescription: "Total duration of the topology operation",
							},
							"total_resources": schema.Int64Attribute{
								Optional:            true,
								Computed:            true,
								Description:         "Total number of resources processed across all types",
								MarkdownDescription: "Total number of resources processed across all types",
							},
						},
						CustomType: ProcessedType{
							ObjectType: types.ObjectType{
								AttrTypes: ProcessedValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Computed:            true,
						Description:         "Detailed breakdown of resources processed during the operation",
						MarkdownDescription: "Detailed breakdown of resources processed during the operation",
					},
					"result": schema.StringAttribute{
						Required:            true,
						Description:         "Overall result of the topology operation",
						MarkdownDescription: "Overall result of the topology operation",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"Success",
								"Failed",
							),
						},
					},
				},
				CustomType: StatusType{
					ObjectType: types.ObjectType{
						AttrTypes: StatusValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Computed:            true,
				Description:         "NetworkTopologyStatus defines the observed state of NetworkTopology",
				MarkdownDescription: "NetworkTopologyStatus defines the observed state of NetworkTopology",
			},
		},
	}
}

type NetworkTopologyModel struct {
	Alarms     AlarmsValue     `tfsdk:"alarms"`
	ApiVersion types.String    `tfsdk:"api_version"`
	Deviations DeviationsValue `tfsdk:"deviations"`
	Kind       types.String    `tfsdk:"kind"`
	Metadata   MetadataValue   `tfsdk:"metadata"`
	Name       types.String    `tfsdk:"name"`
	Namespace  types.String    `tfsdk:"namespace"`
	Spec       SpecValue       `tfsdk:"spec"`
	Status     StatusValue     `tfsdk:"status"`
}

var _ basetypes.ObjectTypable = AlarmsType{}

type AlarmsType struct {
	basetypes.ObjectType
}

func (t AlarmsType) Equal(o attr.Type) bool {
	other, ok := o.(AlarmsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AlarmsType) String() string {
	return "AlarmsType"
}

func (t AlarmsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	criticalAttribute, ok := attributes["critical"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`critical is missing from object`)

		return nil, diags
	}

	criticalVal, ok := criticalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`critical expected to be basetypes.Int64Value, was: %T`, criticalAttribute))
	}

	majorAttribute, ok := attributes["major"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`major is missing from object`)

		return nil, diags
	}

	majorVal, ok := majorAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`major expected to be basetypes.Int64Value, was: %T`, majorAttribute))
	}

	minorAttribute, ok := attributes["minor"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`minor is missing from object`)

		return nil, diags
	}

	minorVal, ok := minorAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`minor expected to be basetypes.Int64Value, was: %T`, minorAttribute))
	}

	warningAttribute, ok := attributes["warning"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`warning is missing from object`)

		return nil, diags
	}

	warningVal, ok := warningAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`warning expected to be basetypes.Int64Value, was: %T`, warningAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AlarmsValue{
		Critical: criticalVal,
		Major:    majorVal,
		Minor:    minorVal,
		Warning:  warningVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewAlarmsValueNull() AlarmsValue {
	return AlarmsValue{
		state: attr.ValueStateNull,
	}
}

func NewAlarmsValueUnknown() AlarmsValue {
	return AlarmsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAlarmsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AlarmsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AlarmsValue Attribute Value",
				"While creating a AlarmsValue value, a missing attribute value was detected. "+
					"A AlarmsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AlarmsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AlarmsValue Attribute Type",
				"While creating a AlarmsValue value, an invalid attribute value was detected. "+
					"A AlarmsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AlarmsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AlarmsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AlarmsValue Attribute Value",
				"While creating a AlarmsValue value, an extra attribute value was detected. "+
					"A AlarmsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AlarmsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAlarmsValueUnknown(), diags
	}

	criticalAttribute, ok := attributes["critical"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`critical is missing from object`)

		return NewAlarmsValueUnknown(), diags
	}

	criticalVal, ok := criticalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`critical expected to be basetypes.Int64Value, was: %T`, criticalAttribute))
	}

	majorAttribute, ok := attributes["major"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`major is missing from object`)

		return NewAlarmsValueUnknown(), diags
	}

	majorVal, ok := majorAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`major expected to be basetypes.Int64Value, was: %T`, majorAttribute))
	}

	minorAttribute, ok := attributes["minor"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`minor is missing from object`)

		return NewAlarmsValueUnknown(), diags
	}

	minorVal, ok := minorAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`minor expected to be basetypes.Int64Value, was: %T`, minorAttribute))
	}

	warningAttribute, ok := attributes["warning"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`warning is missing from object`)

		return NewAlarmsValueUnknown(), diags
	}

	warningVal, ok := warningAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`warning expected to be basetypes.Int64Value, was: %T`, warningAttribute))
	}

	if diags.HasError() {
		return NewAlarmsValueUnknown(), diags
	}

	return AlarmsValue{
		Critical: criticalVal,
		Major:    majorVal,
		Minor:    minorVal,
		Warning:  warningVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewAlarmsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AlarmsValue {
	object, diags := NewAlarmsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAlarmsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AlarmsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAlarmsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAlarmsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAlarmsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAlarmsValueMust(AlarmsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AlarmsType) ValueType(ctx context.Context) attr.Value {
	return AlarmsValue{}
}

var _ basetypes.ObjectValuable = AlarmsValue{}

type AlarmsValue struct {
	Critical basetypes.Int64Value `tfsdk:"critical"`
	Major    basetypes.Int64Value `tfsdk:"major"`
	Minor    basetypes.Int64Value `tfsdk:"minor"`
	Warning  basetypes.Int64Value `tfsdk:"warning"`
	state    attr.ValueState
}

func (v AlarmsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["critical"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["major"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["minor"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["warning"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Critical.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["critical"] = val

		val, err = v.Major.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["major"] = val

		val, err = v.Minor.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["minor"] = val

		val, err = v.Warning.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["warning"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AlarmsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AlarmsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AlarmsValue) String() string {
	return "AlarmsValue"
}

func (v AlarmsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"critical": basetypes.Int64Type{},
		"major":    basetypes.Int64Type{},
		"minor":    basetypes.Int64Type{},
		"warning":  basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"critical": v.Critical,
			"major":    v.Major,
			"minor":    v.Minor,
			"warning":  v.Warning,
		})

	return objVal, diags
}

func (v AlarmsValue) Equal(o attr.Value) bool {
	other, ok := o.(AlarmsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Critical.Equal(other.Critical) {
		return false
	}

	if !v.Major.Equal(other.Major) {
		return false
	}

	if !v.Minor.Equal(other.Minor) {
		return false
	}

	if !v.Warning.Equal(other.Warning) {
		return false
	}

	return true
}

func (v AlarmsValue) Type(ctx context.Context) attr.Type {
	return AlarmsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AlarmsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"critical": basetypes.Int64Type{},
		"major":    basetypes.Int64Type{},
		"minor":    basetypes.Int64Type{},
		"warning":  basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = DeviationsType{}

type DeviationsType struct {
	basetypes.ObjectType
}

func (t DeviationsType) Equal(o attr.Type) bool {
	other, ok := o.(DeviationsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DeviationsType) String() string {
	return "DeviationsType"
}

func (t DeviationsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	countAttribute, ok := attributes["count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`count is missing from object`)

		return nil, diags
	}

	countVal, ok := countAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`count expected to be basetypes.Int64Value, was: %T`, countAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DeviationsValue{
		Count: countVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewDeviationsValueNull() DeviationsValue {
	return DeviationsValue{
		state: attr.ValueStateNull,
	}
}

func NewDeviationsValueUnknown() DeviationsValue {
	return DeviationsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDeviationsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DeviationsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DeviationsValue Attribute Value",
				"While creating a DeviationsValue value, a missing attribute value was detected. "+
					"A DeviationsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DeviationsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DeviationsValue Attribute Type",
				"While creating a DeviationsValue value, an invalid attribute value was detected. "+
					"A DeviationsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DeviationsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DeviationsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DeviationsValue Attribute Value",
				"While creating a DeviationsValue value, an extra attribute value was detected. "+
					"A DeviationsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DeviationsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDeviationsValueUnknown(), diags
	}

	countAttribute, ok := attributes["count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`count is missing from object`)

		return NewDeviationsValueUnknown(), diags
	}

	countVal, ok := countAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`count expected to be basetypes.Int64Value, was: %T`, countAttribute))
	}

	if diags.HasError() {
		return NewDeviationsValueUnknown(), diags
	}

	return DeviationsValue{
		Count: countVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewDeviationsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DeviationsValue {
	object, diags := NewDeviationsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDeviationsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DeviationsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDeviationsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDeviationsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDeviationsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDeviationsValueMust(DeviationsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DeviationsType) ValueType(ctx context.Context) attr.Value {
	return DeviationsValue{}
}

var _ basetypes.ObjectValuable = DeviationsValue{}

type DeviationsValue struct {
	Count basetypes.Int64Value `tfsdk:"count"`
	state attr.ValueState
}

func (v DeviationsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["count"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Count.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["count"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DeviationsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DeviationsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DeviationsValue) String() string {
	return "DeviationsValue"
}

func (v DeviationsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"count": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"count": v.Count,
		})

	return objVal, diags
}

func (v DeviationsValue) Equal(o attr.Value) bool {
	other, ok := o.(DeviationsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Count.Equal(other.Count) {
		return false
	}

	return true
}

func (v DeviationsValue) Type(ctx context.Context) attr.Type {
	return DeviationsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DeviationsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"count": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = MetadataType{}

type MetadataType struct {
	basetypes.ObjectType
}

func (t MetadataType) Equal(o attr.Type) bool {
	other, ok := o.(MetadataType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MetadataType) String() string {
	return "MetadataType"
}

func (t MetadataType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	annotationsAttribute, ok := attributes["annotations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`annotations is missing from object`)

		return nil, diags
	}

	annotationsVal, ok := annotationsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`annotations expected to be basetypes.MapValue, was: %T`, annotationsAttribute))
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return nil, diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.MapValue, was: %T`, labelsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	namespaceAttribute, ok := attributes["namespace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`namespace is missing from object`)

		return nil, diags
	}

	namespaceVal, ok := namespaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`namespace expected to be basetypes.StringValue, was: %T`, namespaceAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MetadataValue{
		Annotations: annotationsVal,
		Labels:      labelsVal,
		Name:        nameVal,
		Namespace:   namespaceVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewMetadataValueNull() MetadataValue {
	return MetadataValue{
		state: attr.ValueStateNull,
	}
}

func NewMetadataValueUnknown() MetadataValue {
	return MetadataValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMetadataValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MetadataValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MetadataValue Attribute Value",
				"While creating a MetadataValue value, a missing attribute value was detected. "+
					"A MetadataValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MetadataValue Attribute Type",
				"While creating a MetadataValue value, an invalid attribute value was detected. "+
					"A MetadataValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MetadataValue Attribute Value",
				"While creating a MetadataValue value, an extra attribute value was detected. "+
					"A MetadataValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MetadataValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMetadataValueUnknown(), diags
	}

	annotationsAttribute, ok := attributes["annotations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`annotations is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	annotationsVal, ok := annotationsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`annotations expected to be basetypes.MapValue, was: %T`, annotationsAttribute))
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.MapValue, was: %T`, labelsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	namespaceAttribute, ok := attributes["namespace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`namespace is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	namespaceVal, ok := namespaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`namespace expected to be basetypes.StringValue, was: %T`, namespaceAttribute))
	}

	if diags.HasError() {
		return NewMetadataValueUnknown(), diags
	}

	return MetadataValue{
		Annotations: annotationsVal,
		Labels:      labelsVal,
		Name:        nameVal,
		Namespace:   namespaceVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewMetadataValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MetadataValue {
	object, diags := NewMetadataValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMetadataValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MetadataType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMetadataValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMetadataValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMetadataValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMetadataValueMust(MetadataValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MetadataType) ValueType(ctx context.Context) attr.Value {
	return MetadataValue{}
}

var _ basetypes.ObjectValuable = MetadataValue{}

type MetadataValue struct {
	Annotations basetypes.MapValue    `tfsdk:"annotations"`
	Labels      basetypes.MapValue    `tfsdk:"labels"`
	Name        basetypes.StringValue `tfsdk:"name"`
	Namespace   basetypes.StringValue `tfsdk:"namespace"`
	state       attr.ValueState
}

func (v MetadataValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["annotations"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["labels"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["namespace"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Annotations.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["annotations"] = val

		val, err = v.Labels.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["labels"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Namespace.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["namespace"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MetadataValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MetadataValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MetadataValue) String() string {
	return "MetadataValue"
}

func (v MetadataValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var annotationsVal basetypes.MapValue
	switch {
	case v.Annotations.IsUnknown():
		annotationsVal = types.MapUnknown(types.StringType)
	case v.Annotations.IsNull():
		annotationsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		annotationsVal, d = types.MapValue(types.StringType, v.Annotations.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"annotations": basetypes.MapType{
				ElemType: types.StringType,
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"name":      basetypes.StringType{},
			"namespace": basetypes.StringType{},
		}), diags
	}

	var labelsVal basetypes.MapValue
	switch {
	case v.Labels.IsUnknown():
		labelsVal = types.MapUnknown(types.StringType)
	case v.Labels.IsNull():
		labelsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		labelsVal, d = types.MapValue(types.StringType, v.Labels.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"annotations": basetypes.MapType{
				ElemType: types.StringType,
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"name":      basetypes.StringType{},
			"namespace": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"annotations": basetypes.MapType{
			ElemType: types.StringType,
		},
		"labels": basetypes.MapType{
			ElemType: types.StringType,
		},
		"name":      basetypes.StringType{},
		"namespace": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"annotations": annotationsVal,
			"labels":      labelsVal,
			"name":        v.Name,
			"namespace":   v.Namespace,
		})

	return objVal, diags
}

func (v MetadataValue) Equal(o attr.Value) bool {
	other, ok := o.(MetadataValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Annotations.Equal(other.Annotations) {
		return false
	}

	if !v.Labels.Equal(other.Labels) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Namespace.Equal(other.Namespace) {
		return false
	}

	return true
}

func (v MetadataValue) Type(ctx context.Context) attr.Type {
	return MetadataType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MetadataValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"annotations": basetypes.MapType{
			ElemType: types.StringType,
		},
		"labels": basetypes.MapType{
			ElemType: types.StringType,
		},
		"name":      basetypes.StringType{},
		"namespace": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = SpecType{}

type SpecType struct {
	basetypes.ObjectType
}

func (t SpecType) Equal(o attr.Type) bool {
	other, ok := o.(SpecType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SpecType) String() string {
	return "SpecType"
}

func (t SpecType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	breakoutTemplatesAttribute, ok := attributes["breakout_templates"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`breakout_templates is missing from object`)

		return nil, diags
	}

	breakoutTemplatesVal, ok := breakoutTemplatesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`breakout_templates expected to be basetypes.ListValue, was: %T`, breakoutTemplatesAttribute))
	}

	breakoutsAttribute, ok := attributes["breakouts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`breakouts is missing from object`)

		return nil, diags
	}

	breakoutsVal, ok := breakoutsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`breakouts expected to be basetypes.ListValue, was: %T`, breakoutsAttribute))
	}

	checksAttribute, ok := attributes["checks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`checks is missing from object`)

		return nil, diags
	}

	checksVal, ok := checksAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`checks expected to be basetypes.ObjectValue, was: %T`, checksAttribute))
	}

	linkTemplatesAttribute, ok := attributes["link_templates"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`link_templates is missing from object`)

		return nil, diags
	}

	linkTemplatesVal, ok := linkTemplatesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`link_templates expected to be basetypes.ListValue, was: %T`, linkTemplatesAttribute))
	}

	linksAttribute, ok := attributes["links"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`links is missing from object`)

		return nil, diags
	}

	linksVal, ok := linksAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`links expected to be basetypes.ListValue, was: %T`, linksAttribute))
	}

	nodeTemplatesAttribute, ok := attributes["node_templates"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node_templates is missing from object`)

		return nil, diags
	}

	nodeTemplatesVal, ok := nodeTemplatesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node_templates expected to be basetypes.ListValue, was: %T`, nodeTemplatesAttribute))
	}

	nodesAttribute, ok := attributes["nodes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`nodes is missing from object`)

		return nil, diags
	}

	nodesVal, ok := nodesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`nodes expected to be basetypes.ListValue, was: %T`, nodesAttribute))
	}

	operationAttribute, ok := attributes["operation"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operation is missing from object`)

		return nil, diags
	}

	operationVal, ok := operationAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operation expected to be basetypes.StringValue, was: %T`, operationAttribute))
	}

	remoteLocationAttribute, ok := attributes["remote_location"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_location is missing from object`)

		return nil, diags
	}

	remoteLocationVal, ok := remoteLocationAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_location expected to be basetypes.StringValue, was: %T`, remoteLocationAttribute))
	}

	simulationAttribute, ok := attributes["simulation"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`simulation is missing from object`)

		return nil, diags
	}

	simulationVal, ok := simulationAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`simulation expected to be basetypes.ObjectValue, was: %T`, simulationAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SpecValue{
		BreakoutTemplates: breakoutTemplatesVal,
		Breakouts:         breakoutsVal,
		Checks:            checksVal,
		LinkTemplates:     linkTemplatesVal,
		Links:             linksVal,
		NodeTemplates:     nodeTemplatesVal,
		Nodes:             nodesVal,
		Operation:         operationVal,
		RemoteLocation:    remoteLocationVal,
		Simulation:        simulationVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewSpecValueNull() SpecValue {
	return SpecValue{
		state: attr.ValueStateNull,
	}
}

func NewSpecValueUnknown() SpecValue {
	return SpecValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSpecValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SpecValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SpecValue Attribute Value",
				"While creating a SpecValue value, a missing attribute value was detected. "+
					"A SpecValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SpecValue Attribute Type",
				"While creating a SpecValue value, an invalid attribute value was detected. "+
					"A SpecValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SpecValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SpecValue Attribute Value",
				"While creating a SpecValue value, an extra attribute value was detected. "+
					"A SpecValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SpecValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSpecValueUnknown(), diags
	}

	breakoutTemplatesAttribute, ok := attributes["breakout_templates"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`breakout_templates is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	breakoutTemplatesVal, ok := breakoutTemplatesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`breakout_templates expected to be basetypes.ListValue, was: %T`, breakoutTemplatesAttribute))
	}

	breakoutsAttribute, ok := attributes["breakouts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`breakouts is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	breakoutsVal, ok := breakoutsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`breakouts expected to be basetypes.ListValue, was: %T`, breakoutsAttribute))
	}

	checksAttribute, ok := attributes["checks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`checks is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	checksVal, ok := checksAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`checks expected to be basetypes.ObjectValue, was: %T`, checksAttribute))
	}

	linkTemplatesAttribute, ok := attributes["link_templates"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`link_templates is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	linkTemplatesVal, ok := linkTemplatesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`link_templates expected to be basetypes.ListValue, was: %T`, linkTemplatesAttribute))
	}

	linksAttribute, ok := attributes["links"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`links is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	linksVal, ok := linksAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`links expected to be basetypes.ListValue, was: %T`, linksAttribute))
	}

	nodeTemplatesAttribute, ok := attributes["node_templates"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node_templates is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	nodeTemplatesVal, ok := nodeTemplatesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node_templates expected to be basetypes.ListValue, was: %T`, nodeTemplatesAttribute))
	}

	nodesAttribute, ok := attributes["nodes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`nodes is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	nodesVal, ok := nodesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`nodes expected to be basetypes.ListValue, was: %T`, nodesAttribute))
	}

	operationAttribute, ok := attributes["operation"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operation is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	operationVal, ok := operationAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operation expected to be basetypes.StringValue, was: %T`, operationAttribute))
	}

	remoteLocationAttribute, ok := attributes["remote_location"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_location is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	remoteLocationVal, ok := remoteLocationAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_location expected to be basetypes.StringValue, was: %T`, remoteLocationAttribute))
	}

	simulationAttribute, ok := attributes["simulation"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`simulation is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	simulationVal, ok := simulationAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`simulation expected to be basetypes.ObjectValue, was: %T`, simulationAttribute))
	}

	if diags.HasError() {
		return NewSpecValueUnknown(), diags
	}

	return SpecValue{
		BreakoutTemplates: breakoutTemplatesVal,
		Breakouts:         breakoutsVal,
		Checks:            checksVal,
		LinkTemplates:     linkTemplatesVal,
		Links:             linksVal,
		NodeTemplates:     nodeTemplatesVal,
		Nodes:             nodesVal,
		Operation:         operationVal,
		RemoteLocation:    remoteLocationVal,
		Simulation:        simulationVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewSpecValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SpecValue {
	object, diags := NewSpecValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSpecValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SpecType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSpecValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSpecValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSpecValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSpecValueMust(SpecValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SpecType) ValueType(ctx context.Context) attr.Value {
	return SpecValue{}
}

var _ basetypes.ObjectValuable = SpecValue{}

type SpecValue struct {
	BreakoutTemplates basetypes.ListValue   `tfsdk:"breakout_templates"`
	Breakouts         basetypes.ListValue   `tfsdk:"breakouts"`
	Checks            basetypes.ObjectValue `tfsdk:"checks"`
	LinkTemplates     basetypes.ListValue   `tfsdk:"link_templates"`
	Links             basetypes.ListValue   `tfsdk:"links"`
	NodeTemplates     basetypes.ListValue   `tfsdk:"node_templates"`
	Nodes             basetypes.ListValue   `tfsdk:"nodes"`
	Operation         basetypes.StringValue `tfsdk:"operation"`
	RemoteLocation    basetypes.StringValue `tfsdk:"remote_location"`
	Simulation        basetypes.ObjectValue `tfsdk:"simulation"`
	state             attr.ValueState
}

func (v SpecValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 10)

	var val tftypes.Value
	var err error

	attrTypes["breakout_templates"] = basetypes.ListType{
		ElemType: BreakoutTemplatesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["breakouts"] = basetypes.ListType{
		ElemType: BreakoutsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["checks"] = basetypes.ObjectType{
		AttrTypes: ChecksValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["link_templates"] = basetypes.ListType{
		ElemType: LinkTemplatesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["links"] = basetypes.ListType{
		ElemType: LinksValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["node_templates"] = basetypes.ListType{
		ElemType: NodeTemplatesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["nodes"] = basetypes.ListType{
		ElemType: NodesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["operation"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["remote_location"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["simulation"] = basetypes.ObjectType{
		AttrTypes: SimulationValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 10)

		val, err = v.BreakoutTemplates.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["breakout_templates"] = val

		val, err = v.Breakouts.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["breakouts"] = val

		val, err = v.Checks.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["checks"] = val

		val, err = v.LinkTemplates.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["link_templates"] = val

		val, err = v.Links.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["links"] = val

		val, err = v.NodeTemplates.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["node_templates"] = val

		val, err = v.Nodes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["nodes"] = val

		val, err = v.Operation.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["operation"] = val

		val, err = v.RemoteLocation.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["remote_location"] = val

		val, err = v.Simulation.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["simulation"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SpecValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SpecValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SpecValue) String() string {
	return "SpecValue"
}

func (v SpecValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	breakoutTemplates := types.ListValueMust(
		BreakoutTemplatesType{
			basetypes.ObjectType{
				AttrTypes: BreakoutTemplatesValue{}.AttributeTypes(ctx),
			},
		},
		v.BreakoutTemplates.Elements(),
	)

	if v.BreakoutTemplates.IsNull() {
		breakoutTemplates = types.ListNull(
			BreakoutTemplatesType{
				basetypes.ObjectType{
					AttrTypes: BreakoutTemplatesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.BreakoutTemplates.IsUnknown() {
		breakoutTemplates = types.ListUnknown(
			BreakoutTemplatesType{
				basetypes.ObjectType{
					AttrTypes: BreakoutTemplatesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	breakouts := types.ListValueMust(
		BreakoutsType{
			basetypes.ObjectType{
				AttrTypes: BreakoutsValue{}.AttributeTypes(ctx),
			},
		},
		v.Breakouts.Elements(),
	)

	if v.Breakouts.IsNull() {
		breakouts = types.ListNull(
			BreakoutsType{
				basetypes.ObjectType{
					AttrTypes: BreakoutsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Breakouts.IsUnknown() {
		breakouts = types.ListUnknown(
			BreakoutsType{
				basetypes.ObjectType{
					AttrTypes: BreakoutsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var checks basetypes.ObjectValue

	if v.Checks.IsNull() {
		checks = types.ObjectNull(
			ChecksValue{}.AttributeTypes(ctx),
		)
	}

	if v.Checks.IsUnknown() {
		checks = types.ObjectUnknown(
			ChecksValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Checks.IsNull() && !v.Checks.IsUnknown() {
		checks = types.ObjectValueMust(
			ChecksValue{}.AttributeTypes(ctx),
			v.Checks.Attributes(),
		)
	}

	linkTemplates := types.ListValueMust(
		LinkTemplatesType{
			basetypes.ObjectType{
				AttrTypes: LinkTemplatesValue{}.AttributeTypes(ctx),
			},
		},
		v.LinkTemplates.Elements(),
	)

	if v.LinkTemplates.IsNull() {
		linkTemplates = types.ListNull(
			LinkTemplatesType{
				basetypes.ObjectType{
					AttrTypes: LinkTemplatesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.LinkTemplates.IsUnknown() {
		linkTemplates = types.ListUnknown(
			LinkTemplatesType{
				basetypes.ObjectType{
					AttrTypes: LinkTemplatesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	links := types.ListValueMust(
		LinksType{
			basetypes.ObjectType{
				AttrTypes: LinksValue{}.AttributeTypes(ctx),
			},
		},
		v.Links.Elements(),
	)

	if v.Links.IsNull() {
		links = types.ListNull(
			LinksType{
				basetypes.ObjectType{
					AttrTypes: LinksValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Links.IsUnknown() {
		links = types.ListUnknown(
			LinksType{
				basetypes.ObjectType{
					AttrTypes: LinksValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	nodeTemplates := types.ListValueMust(
		NodeTemplatesType{
			basetypes.ObjectType{
				AttrTypes: NodeTemplatesValue{}.AttributeTypes(ctx),
			},
		},
		v.NodeTemplates.Elements(),
	)

	if v.NodeTemplates.IsNull() {
		nodeTemplates = types.ListNull(
			NodeTemplatesType{
				basetypes.ObjectType{
					AttrTypes: NodeTemplatesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.NodeTemplates.IsUnknown() {
		nodeTemplates = types.ListUnknown(
			NodeTemplatesType{
				basetypes.ObjectType{
					AttrTypes: NodeTemplatesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	nodes := types.ListValueMust(
		NodesType{
			basetypes.ObjectType{
				AttrTypes: NodesValue{}.AttributeTypes(ctx),
			},
		},
		v.Nodes.Elements(),
	)

	if v.Nodes.IsNull() {
		nodes = types.ListNull(
			NodesType{
				basetypes.ObjectType{
					AttrTypes: NodesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Nodes.IsUnknown() {
		nodes = types.ListUnknown(
			NodesType{
				basetypes.ObjectType{
					AttrTypes: NodesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var simulation basetypes.ObjectValue

	if v.Simulation.IsNull() {
		simulation = types.ObjectNull(
			SimulationValue{}.AttributeTypes(ctx),
		)
	}

	if v.Simulation.IsUnknown() {
		simulation = types.ObjectUnknown(
			SimulationValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Simulation.IsNull() && !v.Simulation.IsUnknown() {
		simulation = types.ObjectValueMust(
			SimulationValue{}.AttributeTypes(ctx),
			v.Simulation.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"breakout_templates": basetypes.ListType{
			ElemType: BreakoutTemplatesValue{}.Type(ctx),
		},
		"breakouts": basetypes.ListType{
			ElemType: BreakoutsValue{}.Type(ctx),
		},
		"checks": basetypes.ObjectType{
			AttrTypes: ChecksValue{}.AttributeTypes(ctx),
		},
		"link_templates": basetypes.ListType{
			ElemType: LinkTemplatesValue{}.Type(ctx),
		},
		"links": basetypes.ListType{
			ElemType: LinksValue{}.Type(ctx),
		},
		"node_templates": basetypes.ListType{
			ElemType: NodeTemplatesValue{}.Type(ctx),
		},
		"nodes": basetypes.ListType{
			ElemType: NodesValue{}.Type(ctx),
		},
		"operation":       basetypes.StringType{},
		"remote_location": basetypes.StringType{},
		"simulation": basetypes.ObjectType{
			AttrTypes: SimulationValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"breakout_templates": breakoutTemplates,
			"breakouts":          breakouts,
			"checks":             checks,
			"link_templates":     linkTemplates,
			"links":              links,
			"node_templates":     nodeTemplates,
			"nodes":              nodes,
			"operation":          v.Operation,
			"remote_location":    v.RemoteLocation,
			"simulation":         simulation,
		})

	return objVal, diags
}

func (v SpecValue) Equal(o attr.Value) bool {
	other, ok := o.(SpecValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.BreakoutTemplates.Equal(other.BreakoutTemplates) {
		return false
	}

	if !v.Breakouts.Equal(other.Breakouts) {
		return false
	}

	if !v.Checks.Equal(other.Checks) {
		return false
	}

	if !v.LinkTemplates.Equal(other.LinkTemplates) {
		return false
	}

	if !v.Links.Equal(other.Links) {
		return false
	}

	if !v.NodeTemplates.Equal(other.NodeTemplates) {
		return false
	}

	if !v.Nodes.Equal(other.Nodes) {
		return false
	}

	if !v.Operation.Equal(other.Operation) {
		return false
	}

	if !v.RemoteLocation.Equal(other.RemoteLocation) {
		return false
	}

	if !v.Simulation.Equal(other.Simulation) {
		return false
	}

	return true
}

func (v SpecValue) Type(ctx context.Context) attr.Type {
	return SpecType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SpecValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"breakout_templates": basetypes.ListType{
			ElemType: BreakoutTemplatesValue{}.Type(ctx),
		},
		"breakouts": basetypes.ListType{
			ElemType: BreakoutsValue{}.Type(ctx),
		},
		"checks": basetypes.ObjectType{
			AttrTypes: ChecksValue{}.AttributeTypes(ctx),
		},
		"link_templates": basetypes.ListType{
			ElemType: LinkTemplatesValue{}.Type(ctx),
		},
		"links": basetypes.ListType{
			ElemType: LinksValue{}.Type(ctx),
		},
		"node_templates": basetypes.ListType{
			ElemType: NodeTemplatesValue{}.Type(ctx),
		},
		"nodes": basetypes.ListType{
			ElemType: NodesValue{}.Type(ctx),
		},
		"operation":       basetypes.StringType{},
		"remote_location": basetypes.StringType{},
		"simulation": basetypes.ObjectType{
			AttrTypes: SimulationValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = BreakoutTemplatesType{}

type BreakoutTemplatesType struct {
	basetypes.ObjectType
}

func (t BreakoutTemplatesType) Equal(o attr.Type) bool {
	other, ok := o.(BreakoutTemplatesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t BreakoutTemplatesType) String() string {
	return "BreakoutTemplatesType"
}

func (t BreakoutTemplatesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	annotationsAttribute, ok := attributes["annotations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`annotations is missing from object`)

		return nil, diags
	}

	annotationsVal, ok := annotationsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`annotations expected to be basetypes.MapValue, was: %T`, annotationsAttribute))
	}

	channelsAttribute, ok := attributes["channels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`channels is missing from object`)

		return nil, diags
	}

	channelsVal, ok := channelsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`channels expected to be basetypes.Int64Value, was: %T`, channelsAttribute))
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return nil, diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.MapValue, was: %T`, labelsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	speedAttribute, ok := attributes["speed"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`speed is missing from object`)

		return nil, diags
	}

	speedVal, ok := speedAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`speed expected to be basetypes.StringValue, was: %T`, speedAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return BreakoutTemplatesValue{
		Annotations: annotationsVal,
		Channels:    channelsVal,
		Labels:      labelsVal,
		Name:        nameVal,
		Speed:       speedVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewBreakoutTemplatesValueNull() BreakoutTemplatesValue {
	return BreakoutTemplatesValue{
		state: attr.ValueStateNull,
	}
}

func NewBreakoutTemplatesValueUnknown() BreakoutTemplatesValue {
	return BreakoutTemplatesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewBreakoutTemplatesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (BreakoutTemplatesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing BreakoutTemplatesValue Attribute Value",
				"While creating a BreakoutTemplatesValue value, a missing attribute value was detected. "+
					"A BreakoutTemplatesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BreakoutTemplatesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid BreakoutTemplatesValue Attribute Type",
				"While creating a BreakoutTemplatesValue value, an invalid attribute value was detected. "+
					"A BreakoutTemplatesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BreakoutTemplatesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("BreakoutTemplatesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra BreakoutTemplatesValue Attribute Value",
				"While creating a BreakoutTemplatesValue value, an extra attribute value was detected. "+
					"A BreakoutTemplatesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra BreakoutTemplatesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewBreakoutTemplatesValueUnknown(), diags
	}

	annotationsAttribute, ok := attributes["annotations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`annotations is missing from object`)

		return NewBreakoutTemplatesValueUnknown(), diags
	}

	annotationsVal, ok := annotationsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`annotations expected to be basetypes.MapValue, was: %T`, annotationsAttribute))
	}

	channelsAttribute, ok := attributes["channels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`channels is missing from object`)

		return NewBreakoutTemplatesValueUnknown(), diags
	}

	channelsVal, ok := channelsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`channels expected to be basetypes.Int64Value, was: %T`, channelsAttribute))
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return NewBreakoutTemplatesValueUnknown(), diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.MapValue, was: %T`, labelsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewBreakoutTemplatesValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	speedAttribute, ok := attributes["speed"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`speed is missing from object`)

		return NewBreakoutTemplatesValueUnknown(), diags
	}

	speedVal, ok := speedAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`speed expected to be basetypes.StringValue, was: %T`, speedAttribute))
	}

	if diags.HasError() {
		return NewBreakoutTemplatesValueUnknown(), diags
	}

	return BreakoutTemplatesValue{
		Annotations: annotationsVal,
		Channels:    channelsVal,
		Labels:      labelsVal,
		Name:        nameVal,
		Speed:       speedVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewBreakoutTemplatesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) BreakoutTemplatesValue {
	object, diags := NewBreakoutTemplatesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewBreakoutTemplatesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t BreakoutTemplatesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewBreakoutTemplatesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewBreakoutTemplatesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewBreakoutTemplatesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewBreakoutTemplatesValueMust(BreakoutTemplatesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t BreakoutTemplatesType) ValueType(ctx context.Context) attr.Value {
	return BreakoutTemplatesValue{}
}

var _ basetypes.ObjectValuable = BreakoutTemplatesValue{}

type BreakoutTemplatesValue struct {
	Annotations basetypes.MapValue    `tfsdk:"annotations"`
	Channels    basetypes.Int64Value  `tfsdk:"channels"`
	Labels      basetypes.MapValue    `tfsdk:"labels"`
	Name        basetypes.StringValue `tfsdk:"name"`
	Speed       basetypes.StringValue `tfsdk:"speed"`
	state       attr.ValueState
}

func (v BreakoutTemplatesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["annotations"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["channels"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["labels"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["speed"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Annotations.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["annotations"] = val

		val, err = v.Channels.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["channels"] = val

		val, err = v.Labels.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["labels"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Speed.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["speed"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v BreakoutTemplatesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v BreakoutTemplatesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v BreakoutTemplatesValue) String() string {
	return "BreakoutTemplatesValue"
}

func (v BreakoutTemplatesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var annotationsVal basetypes.MapValue
	switch {
	case v.Annotations.IsUnknown():
		annotationsVal = types.MapUnknown(types.StringType)
	case v.Annotations.IsNull():
		annotationsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		annotationsVal, d = types.MapValue(types.StringType, v.Annotations.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"annotations": basetypes.MapType{
				ElemType: types.StringType,
			},
			"channels": basetypes.Int64Type{},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"name":  basetypes.StringType{},
			"speed": basetypes.StringType{},
		}), diags
	}

	var labelsVal basetypes.MapValue
	switch {
	case v.Labels.IsUnknown():
		labelsVal = types.MapUnknown(types.StringType)
	case v.Labels.IsNull():
		labelsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		labelsVal, d = types.MapValue(types.StringType, v.Labels.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"annotations": basetypes.MapType{
				ElemType: types.StringType,
			},
			"channels": basetypes.Int64Type{},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"name":  basetypes.StringType{},
			"speed": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"annotations": basetypes.MapType{
			ElemType: types.StringType,
		},
		"channels": basetypes.Int64Type{},
		"labels": basetypes.MapType{
			ElemType: types.StringType,
		},
		"name":  basetypes.StringType{},
		"speed": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"annotations": annotationsVal,
			"channels":    v.Channels,
			"labels":      labelsVal,
			"name":        v.Name,
			"speed":       v.Speed,
		})

	return objVal, diags
}

func (v BreakoutTemplatesValue) Equal(o attr.Value) bool {
	other, ok := o.(BreakoutTemplatesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Annotations.Equal(other.Annotations) {
		return false
	}

	if !v.Channels.Equal(other.Channels) {
		return false
	}

	if !v.Labels.Equal(other.Labels) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Speed.Equal(other.Speed) {
		return false
	}

	return true
}

func (v BreakoutTemplatesValue) Type(ctx context.Context) attr.Type {
	return BreakoutTemplatesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v BreakoutTemplatesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"annotations": basetypes.MapType{
			ElemType: types.StringType,
		},
		"channels": basetypes.Int64Type{},
		"labels": basetypes.MapType{
			ElemType: types.StringType,
		},
		"name":  basetypes.StringType{},
		"speed": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = BreakoutsType{}

type BreakoutsType struct {
	basetypes.ObjectType
}

func (t BreakoutsType) Equal(o attr.Type) bool {
	other, ok := o.(BreakoutsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t BreakoutsType) String() string {
	return "BreakoutsType"
}

func (t BreakoutsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	annotationsAttribute, ok := attributes["annotations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`annotations is missing from object`)

		return nil, diags
	}

	annotationsVal, ok := annotationsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`annotations expected to be basetypes.MapValue, was: %T`, annotationsAttribute))
	}

	channelsAttribute, ok := attributes["channels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`channels is missing from object`)

		return nil, diags
	}

	channelsVal, ok := channelsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`channels expected to be basetypes.Int64Value, was: %T`, channelsAttribute))
	}

	interfaceAttribute, ok := attributes["interface"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface is missing from object`)

		return nil, diags
	}

	interfaceVal, ok := interfaceAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface expected to be basetypes.ListValue, was: %T`, interfaceAttribute))
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return nil, diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.MapValue, was: %T`, labelsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	nodeAttribute, ok := attributes["node"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node is missing from object`)

		return nil, diags
	}

	nodeVal, ok := nodeAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node expected to be basetypes.ListValue, was: %T`, nodeAttribute))
	}

	speedAttribute, ok := attributes["speed"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`speed is missing from object`)

		return nil, diags
	}

	speedVal, ok := speedAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`speed expected to be basetypes.StringValue, was: %T`, speedAttribute))
	}

	templateAttribute, ok := attributes["template"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`template is missing from object`)

		return nil, diags
	}

	templateVal, ok := templateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`template expected to be basetypes.StringValue, was: %T`, templateAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return BreakoutsValue{
		Annotations: annotationsVal,
		Channels:    channelsVal,
		Interface:   interfaceVal,
		Labels:      labelsVal,
		Name:        nameVal,
		Node:        nodeVal,
		Speed:       speedVal,
		Template:    templateVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewBreakoutsValueNull() BreakoutsValue {
	return BreakoutsValue{
		state: attr.ValueStateNull,
	}
}

func NewBreakoutsValueUnknown() BreakoutsValue {
	return BreakoutsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewBreakoutsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (BreakoutsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing BreakoutsValue Attribute Value",
				"While creating a BreakoutsValue value, a missing attribute value was detected. "+
					"A BreakoutsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BreakoutsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid BreakoutsValue Attribute Type",
				"While creating a BreakoutsValue value, an invalid attribute value was detected. "+
					"A BreakoutsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BreakoutsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("BreakoutsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra BreakoutsValue Attribute Value",
				"While creating a BreakoutsValue value, an extra attribute value was detected. "+
					"A BreakoutsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra BreakoutsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewBreakoutsValueUnknown(), diags
	}

	annotationsAttribute, ok := attributes["annotations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`annotations is missing from object`)

		return NewBreakoutsValueUnknown(), diags
	}

	annotationsVal, ok := annotationsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`annotations expected to be basetypes.MapValue, was: %T`, annotationsAttribute))
	}

	channelsAttribute, ok := attributes["channels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`channels is missing from object`)

		return NewBreakoutsValueUnknown(), diags
	}

	channelsVal, ok := channelsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`channels expected to be basetypes.Int64Value, was: %T`, channelsAttribute))
	}

	interfaceAttribute, ok := attributes["interface"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface is missing from object`)

		return NewBreakoutsValueUnknown(), diags
	}

	interfaceVal, ok := interfaceAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface expected to be basetypes.ListValue, was: %T`, interfaceAttribute))
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return NewBreakoutsValueUnknown(), diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.MapValue, was: %T`, labelsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewBreakoutsValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	nodeAttribute, ok := attributes["node"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node is missing from object`)

		return NewBreakoutsValueUnknown(), diags
	}

	nodeVal, ok := nodeAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node expected to be basetypes.ListValue, was: %T`, nodeAttribute))
	}

	speedAttribute, ok := attributes["speed"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`speed is missing from object`)

		return NewBreakoutsValueUnknown(), diags
	}

	speedVal, ok := speedAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`speed expected to be basetypes.StringValue, was: %T`, speedAttribute))
	}

	templateAttribute, ok := attributes["template"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`template is missing from object`)

		return NewBreakoutsValueUnknown(), diags
	}

	templateVal, ok := templateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`template expected to be basetypes.StringValue, was: %T`, templateAttribute))
	}

	if diags.HasError() {
		return NewBreakoutsValueUnknown(), diags
	}

	return BreakoutsValue{
		Annotations: annotationsVal,
		Channels:    channelsVal,
		Interface:   interfaceVal,
		Labels:      labelsVal,
		Name:        nameVal,
		Node:        nodeVal,
		Speed:       speedVal,
		Template:    templateVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewBreakoutsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) BreakoutsValue {
	object, diags := NewBreakoutsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewBreakoutsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t BreakoutsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewBreakoutsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewBreakoutsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewBreakoutsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewBreakoutsValueMust(BreakoutsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t BreakoutsType) ValueType(ctx context.Context) attr.Value {
	return BreakoutsValue{}
}

var _ basetypes.ObjectValuable = BreakoutsValue{}

type BreakoutsValue struct {
	Annotations basetypes.MapValue    `tfsdk:"annotations"`
	Channels    basetypes.Int64Value  `tfsdk:"channels"`
	Interface   basetypes.ListValue   `tfsdk:"interface"`
	Labels      basetypes.MapValue    `tfsdk:"labels"`
	Name        basetypes.StringValue `tfsdk:"name"`
	Node        basetypes.ListValue   `tfsdk:"node"`
	Speed       basetypes.StringValue `tfsdk:"speed"`
	Template    basetypes.StringValue `tfsdk:"template"`
	state       attr.ValueState
}

func (v BreakoutsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 8)

	var val tftypes.Value
	var err error

	attrTypes["annotations"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["channels"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["interface"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["labels"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["node"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["speed"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["template"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 8)

		val, err = v.Annotations.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["annotations"] = val

		val, err = v.Channels.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["channels"] = val

		val, err = v.Interface.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface"] = val

		val, err = v.Labels.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["labels"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Node.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["node"] = val

		val, err = v.Speed.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["speed"] = val

		val, err = v.Template.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["template"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v BreakoutsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v BreakoutsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v BreakoutsValue) String() string {
	return "BreakoutsValue"
}

func (v BreakoutsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var annotationsVal basetypes.MapValue
	switch {
	case v.Annotations.IsUnknown():
		annotationsVal = types.MapUnknown(types.StringType)
	case v.Annotations.IsNull():
		annotationsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		annotationsVal, d = types.MapValue(types.StringType, v.Annotations.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"annotations": basetypes.MapType{
				ElemType: types.StringType,
			},
			"channels": basetypes.Int64Type{},
			"interface": basetypes.ListType{
				ElemType: types.StringType,
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"name": basetypes.StringType{},
			"node": basetypes.ListType{
				ElemType: types.StringType,
			},
			"speed":    basetypes.StringType{},
			"template": basetypes.StringType{},
		}), diags
	}

	var interfaceVal basetypes.ListValue
	switch {
	case v.Interface.IsUnknown():
		interfaceVal = types.ListUnknown(types.StringType)
	case v.Interface.IsNull():
		interfaceVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		interfaceVal, d = types.ListValue(types.StringType, v.Interface.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"annotations": basetypes.MapType{
				ElemType: types.StringType,
			},
			"channels": basetypes.Int64Type{},
			"interface": basetypes.ListType{
				ElemType: types.StringType,
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"name": basetypes.StringType{},
			"node": basetypes.ListType{
				ElemType: types.StringType,
			},
			"speed":    basetypes.StringType{},
			"template": basetypes.StringType{},
		}), diags
	}

	var labelsVal basetypes.MapValue
	switch {
	case v.Labels.IsUnknown():
		labelsVal = types.MapUnknown(types.StringType)
	case v.Labels.IsNull():
		labelsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		labelsVal, d = types.MapValue(types.StringType, v.Labels.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"annotations": basetypes.MapType{
				ElemType: types.StringType,
			},
			"channels": basetypes.Int64Type{},
			"interface": basetypes.ListType{
				ElemType: types.StringType,
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"name": basetypes.StringType{},
			"node": basetypes.ListType{
				ElemType: types.StringType,
			},
			"speed":    basetypes.StringType{},
			"template": basetypes.StringType{},
		}), diags
	}

	var nodeVal basetypes.ListValue
	switch {
	case v.Node.IsUnknown():
		nodeVal = types.ListUnknown(types.StringType)
	case v.Node.IsNull():
		nodeVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		nodeVal, d = types.ListValue(types.StringType, v.Node.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"annotations": basetypes.MapType{
				ElemType: types.StringType,
			},
			"channels": basetypes.Int64Type{},
			"interface": basetypes.ListType{
				ElemType: types.StringType,
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"name": basetypes.StringType{},
			"node": basetypes.ListType{
				ElemType: types.StringType,
			},
			"speed":    basetypes.StringType{},
			"template": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"annotations": basetypes.MapType{
			ElemType: types.StringType,
		},
		"channels": basetypes.Int64Type{},
		"interface": basetypes.ListType{
			ElemType: types.StringType,
		},
		"labels": basetypes.MapType{
			ElemType: types.StringType,
		},
		"name": basetypes.StringType{},
		"node": basetypes.ListType{
			ElemType: types.StringType,
		},
		"speed":    basetypes.StringType{},
		"template": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"annotations": annotationsVal,
			"channels":    v.Channels,
			"interface":   interfaceVal,
			"labels":      labelsVal,
			"name":        v.Name,
			"node":        nodeVal,
			"speed":       v.Speed,
			"template":    v.Template,
		})

	return objVal, diags
}

func (v BreakoutsValue) Equal(o attr.Value) bool {
	other, ok := o.(BreakoutsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Annotations.Equal(other.Annotations) {
		return false
	}

	if !v.Channels.Equal(other.Channels) {
		return false
	}

	if !v.Interface.Equal(other.Interface) {
		return false
	}

	if !v.Labels.Equal(other.Labels) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Node.Equal(other.Node) {
		return false
	}

	if !v.Speed.Equal(other.Speed) {
		return false
	}

	if !v.Template.Equal(other.Template) {
		return false
	}

	return true
}

func (v BreakoutsValue) Type(ctx context.Context) attr.Type {
	return BreakoutsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v BreakoutsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"annotations": basetypes.MapType{
			ElemType: types.StringType,
		},
		"channels": basetypes.Int64Type{},
		"interface": basetypes.ListType{
			ElemType: types.StringType,
		},
		"labels": basetypes.MapType{
			ElemType: types.StringType,
		},
		"name": basetypes.StringType{},
		"node": basetypes.ListType{
			ElemType: types.StringType,
		},
		"speed":    basetypes.StringType{},
		"template": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ChecksType{}

type ChecksType struct {
	basetypes.ObjectType
}

func (t ChecksType) Equal(o attr.Type) bool {
	other, ok := o.(ChecksType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ChecksType) String() string {
	return "ChecksType"
}

func (t ChecksType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	dryRunAttribute, ok := attributes["dry_run"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dry_run is missing from object`)

		return nil, diags
	}

	dryRunVal, ok := dryRunAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dry_run expected to be basetypes.BoolValue, was: %T`, dryRunAttribute))
	}

	promptAttribute, ok := attributes["prompt"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prompt is missing from object`)

		return nil, diags
	}

	promptVal, ok := promptAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prompt expected to be basetypes.ListValue, was: %T`, promptAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ChecksValue{
		DryRun: dryRunVal,
		Prompt: promptVal,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewChecksValueNull() ChecksValue {
	return ChecksValue{
		state: attr.ValueStateNull,
	}
}

func NewChecksValueUnknown() ChecksValue {
	return ChecksValue{
		state: attr.ValueStateUnknown,
	}
}

func NewChecksValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ChecksValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ChecksValue Attribute Value",
				"While creating a ChecksValue value, a missing attribute value was detected. "+
					"A ChecksValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ChecksValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ChecksValue Attribute Type",
				"While creating a ChecksValue value, an invalid attribute value was detected. "+
					"A ChecksValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ChecksValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ChecksValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ChecksValue Attribute Value",
				"While creating a ChecksValue value, an extra attribute value was detected. "+
					"A ChecksValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ChecksValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewChecksValueUnknown(), diags
	}

	dryRunAttribute, ok := attributes["dry_run"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dry_run is missing from object`)

		return NewChecksValueUnknown(), diags
	}

	dryRunVal, ok := dryRunAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dry_run expected to be basetypes.BoolValue, was: %T`, dryRunAttribute))
	}

	promptAttribute, ok := attributes["prompt"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prompt is missing from object`)

		return NewChecksValueUnknown(), diags
	}

	promptVal, ok := promptAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prompt expected to be basetypes.ListValue, was: %T`, promptAttribute))
	}

	if diags.HasError() {
		return NewChecksValueUnknown(), diags
	}

	return ChecksValue{
		DryRun: dryRunVal,
		Prompt: promptVal,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewChecksValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ChecksValue {
	object, diags := NewChecksValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewChecksValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ChecksType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewChecksValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewChecksValueUnknown(), nil
	}

	if in.IsNull() {
		return NewChecksValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewChecksValueMust(ChecksValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ChecksType) ValueType(ctx context.Context) attr.Value {
	return ChecksValue{}
}

var _ basetypes.ObjectValuable = ChecksValue{}

type ChecksValue struct {
	DryRun basetypes.BoolValue `tfsdk:"dry_run"`
	Prompt basetypes.ListValue `tfsdk:"prompt"`
	state  attr.ValueState
}

func (v ChecksValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["dry_run"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["prompt"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.DryRun.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dry_run"] = val

		val, err = v.Prompt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["prompt"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ChecksValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ChecksValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ChecksValue) String() string {
	return "ChecksValue"
}

func (v ChecksValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var promptVal basetypes.ListValue
	switch {
	case v.Prompt.IsUnknown():
		promptVal = types.ListUnknown(types.StringType)
	case v.Prompt.IsNull():
		promptVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		promptVal, d = types.ListValue(types.StringType, v.Prompt.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"dry_run": basetypes.BoolType{},
			"prompt": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"dry_run": basetypes.BoolType{},
		"prompt": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"dry_run": v.DryRun,
			"prompt":  promptVal,
		})

	return objVal, diags
}

func (v ChecksValue) Equal(o attr.Value) bool {
	other, ok := o.(ChecksValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DryRun.Equal(other.DryRun) {
		return false
	}

	if !v.Prompt.Equal(other.Prompt) {
		return false
	}

	return true
}

func (v ChecksValue) Type(ctx context.Context) attr.Type {
	return ChecksType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ChecksValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"dry_run": basetypes.BoolType{},
		"prompt": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = LinkTemplatesType{}

type LinkTemplatesType struct {
	basetypes.ObjectType
}

func (t LinkTemplatesType) Equal(o attr.Type) bool {
	other, ok := o.(LinkTemplatesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t LinkTemplatesType) String() string {
	return "LinkTemplatesType"
}

func (t LinkTemplatesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	annotationsAttribute, ok := attributes["annotations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`annotations is missing from object`)

		return nil, diags
	}

	annotationsVal, ok := annotationsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`annotations expected to be basetypes.MapValue, was: %T`, annotationsAttribute))
	}

	encapTypeAttribute, ok := attributes["encap_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`encap_type is missing from object`)

		return nil, diags
	}

	encapTypeVal, ok := encapTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`encap_type expected to be basetypes.StringValue, was: %T`, encapTypeAttribute))
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return nil, diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.MapValue, was: %T`, labelsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	speedAttribute, ok := attributes["speed"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`speed is missing from object`)

		return nil, diags
	}

	speedVal, ok := speedAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`speed expected to be basetypes.StringValue, was: %T`, speedAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return LinkTemplatesValue{
		Annotations:       annotationsVal,
		EncapType:         encapTypeVal,
		Labels:            labelsVal,
		Name:              nameVal,
		Speed:             speedVal,
		LinkTemplatesType: typeVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewLinkTemplatesValueNull() LinkTemplatesValue {
	return LinkTemplatesValue{
		state: attr.ValueStateNull,
	}
}

func NewLinkTemplatesValueUnknown() LinkTemplatesValue {
	return LinkTemplatesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewLinkTemplatesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (LinkTemplatesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing LinkTemplatesValue Attribute Value",
				"While creating a LinkTemplatesValue value, a missing attribute value was detected. "+
					"A LinkTemplatesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LinkTemplatesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid LinkTemplatesValue Attribute Type",
				"While creating a LinkTemplatesValue value, an invalid attribute value was detected. "+
					"A LinkTemplatesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LinkTemplatesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("LinkTemplatesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra LinkTemplatesValue Attribute Value",
				"While creating a LinkTemplatesValue value, an extra attribute value was detected. "+
					"A LinkTemplatesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra LinkTemplatesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewLinkTemplatesValueUnknown(), diags
	}

	annotationsAttribute, ok := attributes["annotations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`annotations is missing from object`)

		return NewLinkTemplatesValueUnknown(), diags
	}

	annotationsVal, ok := annotationsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`annotations expected to be basetypes.MapValue, was: %T`, annotationsAttribute))
	}

	encapTypeAttribute, ok := attributes["encap_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`encap_type is missing from object`)

		return NewLinkTemplatesValueUnknown(), diags
	}

	encapTypeVal, ok := encapTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`encap_type expected to be basetypes.StringValue, was: %T`, encapTypeAttribute))
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return NewLinkTemplatesValueUnknown(), diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.MapValue, was: %T`, labelsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewLinkTemplatesValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	speedAttribute, ok := attributes["speed"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`speed is missing from object`)

		return NewLinkTemplatesValueUnknown(), diags
	}

	speedVal, ok := speedAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`speed expected to be basetypes.StringValue, was: %T`, speedAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewLinkTemplatesValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewLinkTemplatesValueUnknown(), diags
	}

	return LinkTemplatesValue{
		Annotations:       annotationsVal,
		EncapType:         encapTypeVal,
		Labels:            labelsVal,
		Name:              nameVal,
		Speed:             speedVal,
		LinkTemplatesType: typeVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewLinkTemplatesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) LinkTemplatesValue {
	object, diags := NewLinkTemplatesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewLinkTemplatesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t LinkTemplatesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewLinkTemplatesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewLinkTemplatesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewLinkTemplatesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewLinkTemplatesValueMust(LinkTemplatesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t LinkTemplatesType) ValueType(ctx context.Context) attr.Value {
	return LinkTemplatesValue{}
}

var _ basetypes.ObjectValuable = LinkTemplatesValue{}

type LinkTemplatesValue struct {
	Annotations       basetypes.MapValue    `tfsdk:"annotations"`
	EncapType         basetypes.StringValue `tfsdk:"encap_type"`
	Labels            basetypes.MapValue    `tfsdk:"labels"`
	Name              basetypes.StringValue `tfsdk:"name"`
	Speed             basetypes.StringValue `tfsdk:"speed"`
	LinkTemplatesType basetypes.StringValue `tfsdk:"type"`
	state             attr.ValueState
}

func (v LinkTemplatesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["annotations"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["encap_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["labels"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["speed"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.Annotations.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["annotations"] = val

		val, err = v.EncapType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["encap_type"] = val

		val, err = v.Labels.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["labels"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Speed.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["speed"] = val

		val, err = v.LinkTemplatesType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v LinkTemplatesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v LinkTemplatesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v LinkTemplatesValue) String() string {
	return "LinkTemplatesValue"
}

func (v LinkTemplatesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var annotationsVal basetypes.MapValue
	switch {
	case v.Annotations.IsUnknown():
		annotationsVal = types.MapUnknown(types.StringType)
	case v.Annotations.IsNull():
		annotationsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		annotationsVal, d = types.MapValue(types.StringType, v.Annotations.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"annotations": basetypes.MapType{
				ElemType: types.StringType,
			},
			"encap_type": basetypes.StringType{},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"name":  basetypes.StringType{},
			"speed": basetypes.StringType{},
			"type":  basetypes.StringType{},
		}), diags
	}

	var labelsVal basetypes.MapValue
	switch {
	case v.Labels.IsUnknown():
		labelsVal = types.MapUnknown(types.StringType)
	case v.Labels.IsNull():
		labelsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		labelsVal, d = types.MapValue(types.StringType, v.Labels.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"annotations": basetypes.MapType{
				ElemType: types.StringType,
			},
			"encap_type": basetypes.StringType{},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"name":  basetypes.StringType{},
			"speed": basetypes.StringType{},
			"type":  basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"annotations": basetypes.MapType{
			ElemType: types.StringType,
		},
		"encap_type": basetypes.StringType{},
		"labels": basetypes.MapType{
			ElemType: types.StringType,
		},
		"name":  basetypes.StringType{},
		"speed": basetypes.StringType{},
		"type":  basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"annotations": annotationsVal,
			"encap_type":  v.EncapType,
			"labels":      labelsVal,
			"name":        v.Name,
			"speed":       v.Speed,
			"type":        v.LinkTemplatesType,
		})

	return objVal, diags
}

func (v LinkTemplatesValue) Equal(o attr.Value) bool {
	other, ok := o.(LinkTemplatesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Annotations.Equal(other.Annotations) {
		return false
	}

	if !v.EncapType.Equal(other.EncapType) {
		return false
	}

	if !v.Labels.Equal(other.Labels) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Speed.Equal(other.Speed) {
		return false
	}

	if !v.LinkTemplatesType.Equal(other.LinkTemplatesType) {
		return false
	}

	return true
}

func (v LinkTemplatesValue) Type(ctx context.Context) attr.Type {
	return LinkTemplatesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v LinkTemplatesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"annotations": basetypes.MapType{
			ElemType: types.StringType,
		},
		"encap_type": basetypes.StringType{},
		"labels": basetypes.MapType{
			ElemType: types.StringType,
		},
		"name":  basetypes.StringType{},
		"speed": basetypes.StringType{},
		"type":  basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = LinksType{}

type LinksType struct {
	basetypes.ObjectType
}

func (t LinksType) Equal(o attr.Type) bool {
	other, ok := o.(LinksType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t LinksType) String() string {
	return "LinksType"
}

func (t LinksType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	annotationsAttribute, ok := attributes["annotations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`annotations is missing from object`)

		return nil, diags
	}

	annotationsVal, ok := annotationsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`annotations expected to be basetypes.MapValue, was: %T`, annotationsAttribute))
	}

	encapTypeAttribute, ok := attributes["encap_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`encap_type is missing from object`)

		return nil, diags
	}

	encapTypeVal, ok := encapTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`encap_type expected to be basetypes.StringValue, was: %T`, encapTypeAttribute))
	}

	endpointsAttribute, ok := attributes["endpoints"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`endpoints is missing from object`)

		return nil, diags
	}

	endpointsVal, ok := endpointsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`endpoints expected to be basetypes.ListValue, was: %T`, endpointsAttribute))
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return nil, diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.MapValue, was: %T`, labelsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	templateAttribute, ok := attributes["template"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`template is missing from object`)

		return nil, diags
	}

	templateVal, ok := templateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`template expected to be basetypes.StringValue, was: %T`, templateAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return LinksValue{
		Annotations: annotationsVal,
		EncapType:   encapTypeVal,
		Endpoints:   endpointsVal,
		Labels:      labelsVal,
		Name:        nameVal,
		Template:    templateVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewLinksValueNull() LinksValue {
	return LinksValue{
		state: attr.ValueStateNull,
	}
}

func NewLinksValueUnknown() LinksValue {
	return LinksValue{
		state: attr.ValueStateUnknown,
	}
}

func NewLinksValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (LinksValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing LinksValue Attribute Value",
				"While creating a LinksValue value, a missing attribute value was detected. "+
					"A LinksValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LinksValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid LinksValue Attribute Type",
				"While creating a LinksValue value, an invalid attribute value was detected. "+
					"A LinksValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LinksValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("LinksValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra LinksValue Attribute Value",
				"While creating a LinksValue value, an extra attribute value was detected. "+
					"A LinksValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra LinksValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewLinksValueUnknown(), diags
	}

	annotationsAttribute, ok := attributes["annotations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`annotations is missing from object`)

		return NewLinksValueUnknown(), diags
	}

	annotationsVal, ok := annotationsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`annotations expected to be basetypes.MapValue, was: %T`, annotationsAttribute))
	}

	encapTypeAttribute, ok := attributes["encap_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`encap_type is missing from object`)

		return NewLinksValueUnknown(), diags
	}

	encapTypeVal, ok := encapTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`encap_type expected to be basetypes.StringValue, was: %T`, encapTypeAttribute))
	}

	endpointsAttribute, ok := attributes["endpoints"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`endpoints is missing from object`)

		return NewLinksValueUnknown(), diags
	}

	endpointsVal, ok := endpointsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`endpoints expected to be basetypes.ListValue, was: %T`, endpointsAttribute))
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return NewLinksValueUnknown(), diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.MapValue, was: %T`, labelsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewLinksValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	templateAttribute, ok := attributes["template"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`template is missing from object`)

		return NewLinksValueUnknown(), diags
	}

	templateVal, ok := templateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`template expected to be basetypes.StringValue, was: %T`, templateAttribute))
	}

	if diags.HasError() {
		return NewLinksValueUnknown(), diags
	}

	return LinksValue{
		Annotations: annotationsVal,
		EncapType:   encapTypeVal,
		Endpoints:   endpointsVal,
		Labels:      labelsVal,
		Name:        nameVal,
		Template:    templateVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewLinksValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) LinksValue {
	object, diags := NewLinksValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewLinksValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t LinksType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewLinksValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewLinksValueUnknown(), nil
	}

	if in.IsNull() {
		return NewLinksValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewLinksValueMust(LinksValue{}.AttributeTypes(ctx), attributes), nil
}

func (t LinksType) ValueType(ctx context.Context) attr.Value {
	return LinksValue{}
}

var _ basetypes.ObjectValuable = LinksValue{}

type LinksValue struct {
	Annotations basetypes.MapValue    `tfsdk:"annotations"`
	EncapType   basetypes.StringValue `tfsdk:"encap_type"`
	Endpoints   basetypes.ListValue   `tfsdk:"endpoints"`
	Labels      basetypes.MapValue    `tfsdk:"labels"`
	Name        basetypes.StringValue `tfsdk:"name"`
	Template    basetypes.StringValue `tfsdk:"template"`
	state       attr.ValueState
}

func (v LinksValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["annotations"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["encap_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["endpoints"] = basetypes.ListType{
		ElemType: EndpointsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["labels"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["template"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.Annotations.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["annotations"] = val

		val, err = v.EncapType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["encap_type"] = val

		val, err = v.Endpoints.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["endpoints"] = val

		val, err = v.Labels.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["labels"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Template.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["template"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v LinksValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v LinksValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v LinksValue) String() string {
	return "LinksValue"
}

func (v LinksValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	endpoints := types.ListValueMust(
		EndpointsType{
			basetypes.ObjectType{
				AttrTypes: EndpointsValue{}.AttributeTypes(ctx),
			},
		},
		v.Endpoints.Elements(),
	)

	if v.Endpoints.IsNull() {
		endpoints = types.ListNull(
			EndpointsType{
				basetypes.ObjectType{
					AttrTypes: EndpointsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Endpoints.IsUnknown() {
		endpoints = types.ListUnknown(
			EndpointsType{
				basetypes.ObjectType{
					AttrTypes: EndpointsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var annotationsVal basetypes.MapValue
	switch {
	case v.Annotations.IsUnknown():
		annotationsVal = types.MapUnknown(types.StringType)
	case v.Annotations.IsNull():
		annotationsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		annotationsVal, d = types.MapValue(types.StringType, v.Annotations.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"annotations": basetypes.MapType{
				ElemType: types.StringType,
			},
			"encap_type": basetypes.StringType{},
			"endpoints": basetypes.ListType{
				ElemType: EndpointsValue{}.Type(ctx),
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"name":     basetypes.StringType{},
			"template": basetypes.StringType{},
		}), diags
	}

	var labelsVal basetypes.MapValue
	switch {
	case v.Labels.IsUnknown():
		labelsVal = types.MapUnknown(types.StringType)
	case v.Labels.IsNull():
		labelsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		labelsVal, d = types.MapValue(types.StringType, v.Labels.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"annotations": basetypes.MapType{
				ElemType: types.StringType,
			},
			"encap_type": basetypes.StringType{},
			"endpoints": basetypes.ListType{
				ElemType: EndpointsValue{}.Type(ctx),
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"name":     basetypes.StringType{},
			"template": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"annotations": basetypes.MapType{
			ElemType: types.StringType,
		},
		"encap_type": basetypes.StringType{},
		"endpoints": basetypes.ListType{
			ElemType: EndpointsValue{}.Type(ctx),
		},
		"labels": basetypes.MapType{
			ElemType: types.StringType,
		},
		"name":     basetypes.StringType{},
		"template": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"annotations": annotationsVal,
			"encap_type":  v.EncapType,
			"endpoints":   endpoints,
			"labels":      labelsVal,
			"name":        v.Name,
			"template":    v.Template,
		})

	return objVal, diags
}

func (v LinksValue) Equal(o attr.Value) bool {
	other, ok := o.(LinksValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Annotations.Equal(other.Annotations) {
		return false
	}

	if !v.EncapType.Equal(other.EncapType) {
		return false
	}

	if !v.Endpoints.Equal(other.Endpoints) {
		return false
	}

	if !v.Labels.Equal(other.Labels) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Template.Equal(other.Template) {
		return false
	}

	return true
}

func (v LinksValue) Type(ctx context.Context) attr.Type {
	return LinksType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v LinksValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"annotations": basetypes.MapType{
			ElemType: types.StringType,
		},
		"encap_type": basetypes.StringType{},
		"endpoints": basetypes.ListType{
			ElemType: EndpointsValue{}.Type(ctx),
		},
		"labels": basetypes.MapType{
			ElemType: types.StringType,
		},
		"name":     basetypes.StringType{},
		"template": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = EndpointsType{}

type EndpointsType struct {
	basetypes.ObjectType
}

func (t EndpointsType) Equal(o attr.Type) bool {
	other, ok := o.(EndpointsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t EndpointsType) String() string {
	return "EndpointsType"
}

func (t EndpointsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	localAttribute, ok := attributes["local"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local is missing from object`)

		return nil, diags
	}

	localVal, ok := localAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local expected to be basetypes.ObjectValue, was: %T`, localAttribute))
	}

	remoteAttribute, ok := attributes["remote"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote is missing from object`)

		return nil, diags
	}

	remoteVal, ok := remoteAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote expected to be basetypes.ObjectValue, was: %T`, remoteAttribute))
	}

	simAttribute, ok := attributes["sim"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sim is missing from object`)

		return nil, diags
	}

	simVal, ok := simAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sim expected to be basetypes.ObjectValue, was: %T`, simAttribute))
	}

	speedAttribute, ok := attributes["speed"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`speed is missing from object`)

		return nil, diags
	}

	speedVal, ok := speedAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`speed expected to be basetypes.StringValue, was: %T`, speedAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return EndpointsValue{
		Local:         localVal,
		Remote:        remoteVal,
		Sim:           simVal,
		Speed:         speedVal,
		EndpointsType: typeVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewEndpointsValueNull() EndpointsValue {
	return EndpointsValue{
		state: attr.ValueStateNull,
	}
}

func NewEndpointsValueUnknown() EndpointsValue {
	return EndpointsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewEndpointsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (EndpointsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing EndpointsValue Attribute Value",
				"While creating a EndpointsValue value, a missing attribute value was detected. "+
					"A EndpointsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("EndpointsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid EndpointsValue Attribute Type",
				"While creating a EndpointsValue value, an invalid attribute value was detected. "+
					"A EndpointsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("EndpointsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("EndpointsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra EndpointsValue Attribute Value",
				"While creating a EndpointsValue value, an extra attribute value was detected. "+
					"A EndpointsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra EndpointsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewEndpointsValueUnknown(), diags
	}

	localAttribute, ok := attributes["local"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local is missing from object`)

		return NewEndpointsValueUnknown(), diags
	}

	localVal, ok := localAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local expected to be basetypes.ObjectValue, was: %T`, localAttribute))
	}

	remoteAttribute, ok := attributes["remote"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote is missing from object`)

		return NewEndpointsValueUnknown(), diags
	}

	remoteVal, ok := remoteAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote expected to be basetypes.ObjectValue, was: %T`, remoteAttribute))
	}

	simAttribute, ok := attributes["sim"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sim is missing from object`)

		return NewEndpointsValueUnknown(), diags
	}

	simVal, ok := simAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sim expected to be basetypes.ObjectValue, was: %T`, simAttribute))
	}

	speedAttribute, ok := attributes["speed"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`speed is missing from object`)

		return NewEndpointsValueUnknown(), diags
	}

	speedVal, ok := speedAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`speed expected to be basetypes.StringValue, was: %T`, speedAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewEndpointsValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewEndpointsValueUnknown(), diags
	}

	return EndpointsValue{
		Local:         localVal,
		Remote:        remoteVal,
		Sim:           simVal,
		Speed:         speedVal,
		EndpointsType: typeVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewEndpointsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) EndpointsValue {
	object, diags := NewEndpointsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewEndpointsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t EndpointsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewEndpointsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewEndpointsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewEndpointsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewEndpointsValueMust(EndpointsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t EndpointsType) ValueType(ctx context.Context) attr.Value {
	return EndpointsValue{}
}

var _ basetypes.ObjectValuable = EndpointsValue{}

type EndpointsValue struct {
	Local         basetypes.ObjectValue `tfsdk:"local"`
	Remote        basetypes.ObjectValue `tfsdk:"remote"`
	Sim           basetypes.ObjectValue `tfsdk:"sim"`
	Speed         basetypes.StringValue `tfsdk:"speed"`
	EndpointsType basetypes.StringValue `tfsdk:"type"`
	state         attr.ValueState
}

func (v EndpointsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["local"] = basetypes.ObjectType{
		AttrTypes: LocalValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["remote"] = basetypes.ObjectType{
		AttrTypes: RemoteValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["sim"] = basetypes.ObjectType{
		AttrTypes: SimValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["speed"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Local.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["local"] = val

		val, err = v.Remote.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["remote"] = val

		val, err = v.Sim.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sim"] = val

		val, err = v.Speed.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["speed"] = val

		val, err = v.EndpointsType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v EndpointsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v EndpointsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v EndpointsValue) String() string {
	return "EndpointsValue"
}

func (v EndpointsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var local basetypes.ObjectValue

	if v.Local.IsNull() {
		local = types.ObjectNull(
			LocalValue{}.AttributeTypes(ctx),
		)
	}

	if v.Local.IsUnknown() {
		local = types.ObjectUnknown(
			LocalValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Local.IsNull() && !v.Local.IsUnknown() {
		local = types.ObjectValueMust(
			LocalValue{}.AttributeTypes(ctx),
			v.Local.Attributes(),
		)
	}

	var remote basetypes.ObjectValue

	if v.Remote.IsNull() {
		remote = types.ObjectNull(
			RemoteValue{}.AttributeTypes(ctx),
		)
	}

	if v.Remote.IsUnknown() {
		remote = types.ObjectUnknown(
			RemoteValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Remote.IsNull() && !v.Remote.IsUnknown() {
		remote = types.ObjectValueMust(
			RemoteValue{}.AttributeTypes(ctx),
			v.Remote.Attributes(),
		)
	}

	var sim basetypes.ObjectValue

	if v.Sim.IsNull() {
		sim = types.ObjectNull(
			SimValue{}.AttributeTypes(ctx),
		)
	}

	if v.Sim.IsUnknown() {
		sim = types.ObjectUnknown(
			SimValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Sim.IsNull() && !v.Sim.IsUnknown() {
		sim = types.ObjectValueMust(
			SimValue{}.AttributeTypes(ctx),
			v.Sim.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"local": basetypes.ObjectType{
			AttrTypes: LocalValue{}.AttributeTypes(ctx),
		},
		"remote": basetypes.ObjectType{
			AttrTypes: RemoteValue{}.AttributeTypes(ctx),
		},
		"sim": basetypes.ObjectType{
			AttrTypes: SimValue{}.AttributeTypes(ctx),
		},
		"speed": basetypes.StringType{},
		"type":  basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"local":  local,
			"remote": remote,
			"sim":    sim,
			"speed":  v.Speed,
			"type":   v.EndpointsType,
		})

	return objVal, diags
}

func (v EndpointsValue) Equal(o attr.Value) bool {
	other, ok := o.(EndpointsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Local.Equal(other.Local) {
		return false
	}

	if !v.Remote.Equal(other.Remote) {
		return false
	}

	if !v.Sim.Equal(other.Sim) {
		return false
	}

	if !v.Speed.Equal(other.Speed) {
		return false
	}

	if !v.EndpointsType.Equal(other.EndpointsType) {
		return false
	}

	return true
}

func (v EndpointsValue) Type(ctx context.Context) attr.Type {
	return EndpointsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v EndpointsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"local": basetypes.ObjectType{
			AttrTypes: LocalValue{}.AttributeTypes(ctx),
		},
		"remote": basetypes.ObjectType{
			AttrTypes: RemoteValue{}.AttributeTypes(ctx),
		},
		"sim": basetypes.ObjectType{
			AttrTypes: SimValue{}.AttributeTypes(ctx),
		},
		"speed": basetypes.StringType{},
		"type":  basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = LocalType{}

type LocalType struct {
	basetypes.ObjectType
}

func (t LocalType) Equal(o attr.Type) bool {
	other, ok := o.(LocalType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t LocalType) String() string {
	return "LocalType"
}

func (t LocalType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	interfaceAttribute, ok := attributes["interface"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface is missing from object`)

		return nil, diags
	}

	interfaceVal, ok := interfaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface expected to be basetypes.StringValue, was: %T`, interfaceAttribute))
	}

	interfaceResourceAttribute, ok := attributes["interface_resource"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_resource is missing from object`)

		return nil, diags
	}

	interfaceResourceVal, ok := interfaceResourceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_resource expected to be basetypes.StringValue, was: %T`, interfaceResourceAttribute))
	}

	nodeAttribute, ok := attributes["node"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node is missing from object`)

		return nil, diags
	}

	nodeVal, ok := nodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node expected to be basetypes.StringValue, was: %T`, nodeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return LocalValue{
		Interface:         interfaceVal,
		InterfaceResource: interfaceResourceVal,
		Node:              nodeVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewLocalValueNull() LocalValue {
	return LocalValue{
		state: attr.ValueStateNull,
	}
}

func NewLocalValueUnknown() LocalValue {
	return LocalValue{
		state: attr.ValueStateUnknown,
	}
}

func NewLocalValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (LocalValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing LocalValue Attribute Value",
				"While creating a LocalValue value, a missing attribute value was detected. "+
					"A LocalValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LocalValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid LocalValue Attribute Type",
				"While creating a LocalValue value, an invalid attribute value was detected. "+
					"A LocalValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LocalValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("LocalValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra LocalValue Attribute Value",
				"While creating a LocalValue value, an extra attribute value was detected. "+
					"A LocalValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra LocalValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewLocalValueUnknown(), diags
	}

	interfaceAttribute, ok := attributes["interface"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface is missing from object`)

		return NewLocalValueUnknown(), diags
	}

	interfaceVal, ok := interfaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface expected to be basetypes.StringValue, was: %T`, interfaceAttribute))
	}

	interfaceResourceAttribute, ok := attributes["interface_resource"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_resource is missing from object`)

		return NewLocalValueUnknown(), diags
	}

	interfaceResourceVal, ok := interfaceResourceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_resource expected to be basetypes.StringValue, was: %T`, interfaceResourceAttribute))
	}

	nodeAttribute, ok := attributes["node"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node is missing from object`)

		return NewLocalValueUnknown(), diags
	}

	nodeVal, ok := nodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node expected to be basetypes.StringValue, was: %T`, nodeAttribute))
	}

	if diags.HasError() {
		return NewLocalValueUnknown(), diags
	}

	return LocalValue{
		Interface:         interfaceVal,
		InterfaceResource: interfaceResourceVal,
		Node:              nodeVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewLocalValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) LocalValue {
	object, diags := NewLocalValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewLocalValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t LocalType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewLocalValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewLocalValueUnknown(), nil
	}

	if in.IsNull() {
		return NewLocalValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewLocalValueMust(LocalValue{}.AttributeTypes(ctx), attributes), nil
}

func (t LocalType) ValueType(ctx context.Context) attr.Value {
	return LocalValue{}
}

var _ basetypes.ObjectValuable = LocalValue{}

type LocalValue struct {
	Interface         basetypes.StringValue `tfsdk:"interface"`
	InterfaceResource basetypes.StringValue `tfsdk:"interface_resource"`
	Node              basetypes.StringValue `tfsdk:"node"`
	state             attr.ValueState
}

func (v LocalValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["interface"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["interface_resource"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["node"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Interface.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface"] = val

		val, err = v.InterfaceResource.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface_resource"] = val

		val, err = v.Node.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["node"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v LocalValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v LocalValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v LocalValue) String() string {
	return "LocalValue"
}

func (v LocalValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"interface":          basetypes.StringType{},
		"interface_resource": basetypes.StringType{},
		"node":               basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"interface":          v.Interface,
			"interface_resource": v.InterfaceResource,
			"node":               v.Node,
		})

	return objVal, diags
}

func (v LocalValue) Equal(o attr.Value) bool {
	other, ok := o.(LocalValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Interface.Equal(other.Interface) {
		return false
	}

	if !v.InterfaceResource.Equal(other.InterfaceResource) {
		return false
	}

	if !v.Node.Equal(other.Node) {
		return false
	}

	return true
}

func (v LocalValue) Type(ctx context.Context) attr.Type {
	return LocalType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v LocalValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"interface":          basetypes.StringType{},
		"interface_resource": basetypes.StringType{},
		"node":               basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = RemoteType{}

type RemoteType struct {
	basetypes.ObjectType
}

func (t RemoteType) Equal(o attr.Type) bool {
	other, ok := o.(RemoteType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t RemoteType) String() string {
	return "RemoteType"
}

func (t RemoteType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	interfaceAttribute, ok := attributes["interface"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface is missing from object`)

		return nil, diags
	}

	interfaceVal, ok := interfaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface expected to be basetypes.StringValue, was: %T`, interfaceAttribute))
	}

	interfaceResourceAttribute, ok := attributes["interface_resource"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_resource is missing from object`)

		return nil, diags
	}

	interfaceResourceVal, ok := interfaceResourceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_resource expected to be basetypes.StringValue, was: %T`, interfaceResourceAttribute))
	}

	nodeAttribute, ok := attributes["node"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node is missing from object`)

		return nil, diags
	}

	nodeVal, ok := nodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node expected to be basetypes.StringValue, was: %T`, nodeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return RemoteValue{
		Interface:         interfaceVal,
		InterfaceResource: interfaceResourceVal,
		Node:              nodeVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewRemoteValueNull() RemoteValue {
	return RemoteValue{
		state: attr.ValueStateNull,
	}
}

func NewRemoteValueUnknown() RemoteValue {
	return RemoteValue{
		state: attr.ValueStateUnknown,
	}
}

func NewRemoteValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (RemoteValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing RemoteValue Attribute Value",
				"While creating a RemoteValue value, a missing attribute value was detected. "+
					"A RemoteValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RemoteValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid RemoteValue Attribute Type",
				"While creating a RemoteValue value, an invalid attribute value was detected. "+
					"A RemoteValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RemoteValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("RemoteValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra RemoteValue Attribute Value",
				"While creating a RemoteValue value, an extra attribute value was detected. "+
					"A RemoteValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra RemoteValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewRemoteValueUnknown(), diags
	}

	interfaceAttribute, ok := attributes["interface"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface is missing from object`)

		return NewRemoteValueUnknown(), diags
	}

	interfaceVal, ok := interfaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface expected to be basetypes.StringValue, was: %T`, interfaceAttribute))
	}

	interfaceResourceAttribute, ok := attributes["interface_resource"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_resource is missing from object`)

		return NewRemoteValueUnknown(), diags
	}

	interfaceResourceVal, ok := interfaceResourceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_resource expected to be basetypes.StringValue, was: %T`, interfaceResourceAttribute))
	}

	nodeAttribute, ok := attributes["node"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node is missing from object`)

		return NewRemoteValueUnknown(), diags
	}

	nodeVal, ok := nodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node expected to be basetypes.StringValue, was: %T`, nodeAttribute))
	}

	if diags.HasError() {
		return NewRemoteValueUnknown(), diags
	}

	return RemoteValue{
		Interface:         interfaceVal,
		InterfaceResource: interfaceResourceVal,
		Node:              nodeVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewRemoteValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) RemoteValue {
	object, diags := NewRemoteValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewRemoteValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t RemoteType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewRemoteValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewRemoteValueUnknown(), nil
	}

	if in.IsNull() {
		return NewRemoteValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewRemoteValueMust(RemoteValue{}.AttributeTypes(ctx), attributes), nil
}

func (t RemoteType) ValueType(ctx context.Context) attr.Value {
	return RemoteValue{}
}

var _ basetypes.ObjectValuable = RemoteValue{}

type RemoteValue struct {
	Interface         basetypes.StringValue `tfsdk:"interface"`
	InterfaceResource basetypes.StringValue `tfsdk:"interface_resource"`
	Node              basetypes.StringValue `tfsdk:"node"`
	state             attr.ValueState
}

func (v RemoteValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["interface"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["interface_resource"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["node"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Interface.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface"] = val

		val, err = v.InterfaceResource.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface_resource"] = val

		val, err = v.Node.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["node"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v RemoteValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v RemoteValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v RemoteValue) String() string {
	return "RemoteValue"
}

func (v RemoteValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"interface":          basetypes.StringType{},
		"interface_resource": basetypes.StringType{},
		"node":               basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"interface":          v.Interface,
			"interface_resource": v.InterfaceResource,
			"node":               v.Node,
		})

	return objVal, diags
}

func (v RemoteValue) Equal(o attr.Value) bool {
	other, ok := o.(RemoteValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Interface.Equal(other.Interface) {
		return false
	}

	if !v.InterfaceResource.Equal(other.InterfaceResource) {
		return false
	}

	if !v.Node.Equal(other.Node) {
		return false
	}

	return true
}

func (v RemoteValue) Type(ctx context.Context) attr.Type {
	return RemoteType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v RemoteValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"interface":          basetypes.StringType{},
		"interface_resource": basetypes.StringType{},
		"node":               basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = SimType{}

type SimType struct {
	basetypes.ObjectType
}

func (t SimType) Equal(o attr.Type) bool {
	other, ok := o.(SimType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SimType) String() string {
	return "SimType"
}

func (t SimType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	simNodeAttribute, ok := attributes["sim_node"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sim_node is missing from object`)

		return nil, diags
	}

	simNodeVal, ok := simNodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sim_node expected to be basetypes.StringValue, was: %T`, simNodeAttribute))
	}

	simNodeInterfaceAttribute, ok := attributes["sim_node_interface"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sim_node_interface is missing from object`)

		return nil, diags
	}

	simNodeInterfaceVal, ok := simNodeInterfaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sim_node_interface expected to be basetypes.StringValue, was: %T`, simNodeInterfaceAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SimValue{
		SimNode:          simNodeVal,
		SimNodeInterface: simNodeInterfaceVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewSimValueNull() SimValue {
	return SimValue{
		state: attr.ValueStateNull,
	}
}

func NewSimValueUnknown() SimValue {
	return SimValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSimValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SimValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SimValue Attribute Value",
				"While creating a SimValue value, a missing attribute value was detected. "+
					"A SimValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SimValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SimValue Attribute Type",
				"While creating a SimValue value, an invalid attribute value was detected. "+
					"A SimValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SimValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SimValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SimValue Attribute Value",
				"While creating a SimValue value, an extra attribute value was detected. "+
					"A SimValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SimValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSimValueUnknown(), diags
	}

	simNodeAttribute, ok := attributes["sim_node"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sim_node is missing from object`)

		return NewSimValueUnknown(), diags
	}

	simNodeVal, ok := simNodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sim_node expected to be basetypes.StringValue, was: %T`, simNodeAttribute))
	}

	simNodeInterfaceAttribute, ok := attributes["sim_node_interface"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sim_node_interface is missing from object`)

		return NewSimValueUnknown(), diags
	}

	simNodeInterfaceVal, ok := simNodeInterfaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sim_node_interface expected to be basetypes.StringValue, was: %T`, simNodeInterfaceAttribute))
	}

	if diags.HasError() {
		return NewSimValueUnknown(), diags
	}

	return SimValue{
		SimNode:          simNodeVal,
		SimNodeInterface: simNodeInterfaceVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewSimValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SimValue {
	object, diags := NewSimValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSimValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SimType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSimValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSimValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSimValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSimValueMust(SimValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SimType) ValueType(ctx context.Context) attr.Value {
	return SimValue{}
}

var _ basetypes.ObjectValuable = SimValue{}

type SimValue struct {
	SimNode          basetypes.StringValue `tfsdk:"sim_node"`
	SimNodeInterface basetypes.StringValue `tfsdk:"sim_node_interface"`
	state            attr.ValueState
}

func (v SimValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["sim_node"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["sim_node_interface"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.SimNode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sim_node"] = val

		val, err = v.SimNodeInterface.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sim_node_interface"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SimValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SimValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SimValue) String() string {
	return "SimValue"
}

func (v SimValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"sim_node":           basetypes.StringType{},
		"sim_node_interface": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"sim_node":           v.SimNode,
			"sim_node_interface": v.SimNodeInterface,
		})

	return objVal, diags
}

func (v SimValue) Equal(o attr.Value) bool {
	other, ok := o.(SimValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.SimNode.Equal(other.SimNode) {
		return false
	}

	if !v.SimNodeInterface.Equal(other.SimNodeInterface) {
		return false
	}

	return true
}

func (v SimValue) Type(ctx context.Context) attr.Type {
	return SimType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SimValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"sim_node":           basetypes.StringType{},
		"sim_node_interface": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = NodeTemplatesType{}

type NodeTemplatesType struct {
	basetypes.ObjectType
}

func (t NodeTemplatesType) Equal(o attr.Type) bool {
	other, ok := o.(NodeTemplatesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t NodeTemplatesType) String() string {
	return "NodeTemplatesType"
}

func (t NodeTemplatesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	annotationsAttribute, ok := attributes["annotations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`annotations is missing from object`)

		return nil, diags
	}

	annotationsVal, ok := annotationsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`annotations expected to be basetypes.MapValue, was: %T`, annotationsAttribute))
	}

	componentAttribute, ok := attributes["component"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`component is missing from object`)

		return nil, diags
	}

	componentVal, ok := componentAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`component expected to be basetypes.ListValue, was: %T`, componentAttribute))
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return nil, diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.MapValue, was: %T`, labelsAttribute))
	}

	licenseAttribute, ok := attributes["license"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`license is missing from object`)

		return nil, diags
	}

	licenseVal, ok := licenseAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`license expected to be basetypes.StringValue, was: %T`, licenseAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	nodeProfileAttribute, ok := attributes["node_profile"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node_profile is missing from object`)

		return nil, diags
	}

	nodeProfileVal, ok := nodeProfileAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node_profile expected to be basetypes.StringValue, was: %T`, nodeProfileAttribute))
	}

	platformAttribute, ok := attributes["platform"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`platform is missing from object`)

		return nil, diags
	}

	platformVal, ok := platformAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`platform expected to be basetypes.StringValue, was: %T`, platformAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return NodeTemplatesValue{
		Annotations: annotationsVal,
		Component:   componentVal,
		Labels:      labelsVal,
		License:     licenseVal,
		Name:        nameVal,
		NodeProfile: nodeProfileVal,
		Platform:    platformVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewNodeTemplatesValueNull() NodeTemplatesValue {
	return NodeTemplatesValue{
		state: attr.ValueStateNull,
	}
}

func NewNodeTemplatesValueUnknown() NodeTemplatesValue {
	return NodeTemplatesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewNodeTemplatesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (NodeTemplatesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing NodeTemplatesValue Attribute Value",
				"While creating a NodeTemplatesValue value, a missing attribute value was detected. "+
					"A NodeTemplatesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NodeTemplatesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid NodeTemplatesValue Attribute Type",
				"While creating a NodeTemplatesValue value, an invalid attribute value was detected. "+
					"A NodeTemplatesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NodeTemplatesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("NodeTemplatesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra NodeTemplatesValue Attribute Value",
				"While creating a NodeTemplatesValue value, an extra attribute value was detected. "+
					"A NodeTemplatesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra NodeTemplatesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewNodeTemplatesValueUnknown(), diags
	}

	annotationsAttribute, ok := attributes["annotations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`annotations is missing from object`)

		return NewNodeTemplatesValueUnknown(), diags
	}

	annotationsVal, ok := annotationsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`annotations expected to be basetypes.MapValue, was: %T`, annotationsAttribute))
	}

	componentAttribute, ok := attributes["component"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`component is missing from object`)

		return NewNodeTemplatesValueUnknown(), diags
	}

	componentVal, ok := componentAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`component expected to be basetypes.ListValue, was: %T`, componentAttribute))
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return NewNodeTemplatesValueUnknown(), diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.MapValue, was: %T`, labelsAttribute))
	}

	licenseAttribute, ok := attributes["license"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`license is missing from object`)

		return NewNodeTemplatesValueUnknown(), diags
	}

	licenseVal, ok := licenseAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`license expected to be basetypes.StringValue, was: %T`, licenseAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewNodeTemplatesValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	nodeProfileAttribute, ok := attributes["node_profile"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node_profile is missing from object`)

		return NewNodeTemplatesValueUnknown(), diags
	}

	nodeProfileVal, ok := nodeProfileAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node_profile expected to be basetypes.StringValue, was: %T`, nodeProfileAttribute))
	}

	platformAttribute, ok := attributes["platform"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`platform is missing from object`)

		return NewNodeTemplatesValueUnknown(), diags
	}

	platformVal, ok := platformAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`platform expected to be basetypes.StringValue, was: %T`, platformAttribute))
	}

	if diags.HasError() {
		return NewNodeTemplatesValueUnknown(), diags
	}

	return NodeTemplatesValue{
		Annotations: annotationsVal,
		Component:   componentVal,
		Labels:      labelsVal,
		License:     licenseVal,
		Name:        nameVal,
		NodeProfile: nodeProfileVal,
		Platform:    platformVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewNodeTemplatesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) NodeTemplatesValue {
	object, diags := NewNodeTemplatesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewNodeTemplatesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t NodeTemplatesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewNodeTemplatesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewNodeTemplatesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewNodeTemplatesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewNodeTemplatesValueMust(NodeTemplatesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t NodeTemplatesType) ValueType(ctx context.Context) attr.Value {
	return NodeTemplatesValue{}
}

var _ basetypes.ObjectValuable = NodeTemplatesValue{}

type NodeTemplatesValue struct {
	Annotations basetypes.MapValue    `tfsdk:"annotations"`
	Component   basetypes.ListValue   `tfsdk:"component"`
	Labels      basetypes.MapValue    `tfsdk:"labels"`
	License     basetypes.StringValue `tfsdk:"license"`
	Name        basetypes.StringValue `tfsdk:"name"`
	NodeProfile basetypes.StringValue `tfsdk:"node_profile"`
	Platform    basetypes.StringValue `tfsdk:"platform"`
	state       attr.ValueState
}

func (v NodeTemplatesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["annotations"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["component"] = basetypes.ListType{
		ElemType: ComponentValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["labels"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["license"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["node_profile"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["platform"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.Annotations.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["annotations"] = val

		val, err = v.Component.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["component"] = val

		val, err = v.Labels.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["labels"] = val

		val, err = v.License.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["license"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.NodeProfile.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["node_profile"] = val

		val, err = v.Platform.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["platform"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v NodeTemplatesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v NodeTemplatesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v NodeTemplatesValue) String() string {
	return "NodeTemplatesValue"
}

func (v NodeTemplatesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	component := types.ListValueMust(
		ComponentType{
			basetypes.ObjectType{
				AttrTypes: ComponentValue{}.AttributeTypes(ctx),
			},
		},
		v.Component.Elements(),
	)

	if v.Component.IsNull() {
		component = types.ListNull(
			ComponentType{
				basetypes.ObjectType{
					AttrTypes: ComponentValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Component.IsUnknown() {
		component = types.ListUnknown(
			ComponentType{
				basetypes.ObjectType{
					AttrTypes: ComponentValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var annotationsVal basetypes.MapValue
	switch {
	case v.Annotations.IsUnknown():
		annotationsVal = types.MapUnknown(types.StringType)
	case v.Annotations.IsNull():
		annotationsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		annotationsVal, d = types.MapValue(types.StringType, v.Annotations.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"annotations": basetypes.MapType{
				ElemType: types.StringType,
			},
			"component": basetypes.ListType{
				ElemType: ComponentValue{}.Type(ctx),
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"license":      basetypes.StringType{},
			"name":         basetypes.StringType{},
			"node_profile": basetypes.StringType{},
			"platform":     basetypes.StringType{},
		}), diags
	}

	var labelsVal basetypes.MapValue
	switch {
	case v.Labels.IsUnknown():
		labelsVal = types.MapUnknown(types.StringType)
	case v.Labels.IsNull():
		labelsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		labelsVal, d = types.MapValue(types.StringType, v.Labels.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"annotations": basetypes.MapType{
				ElemType: types.StringType,
			},
			"component": basetypes.ListType{
				ElemType: ComponentValue{}.Type(ctx),
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"license":      basetypes.StringType{},
			"name":         basetypes.StringType{},
			"node_profile": basetypes.StringType{},
			"platform":     basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"annotations": basetypes.MapType{
			ElemType: types.StringType,
		},
		"component": basetypes.ListType{
			ElemType: ComponentValue{}.Type(ctx),
		},
		"labels": basetypes.MapType{
			ElemType: types.StringType,
		},
		"license":      basetypes.StringType{},
		"name":         basetypes.StringType{},
		"node_profile": basetypes.StringType{},
		"platform":     basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"annotations":  annotationsVal,
			"component":    component,
			"labels":       labelsVal,
			"license":      v.License,
			"name":         v.Name,
			"node_profile": v.NodeProfile,
			"platform":     v.Platform,
		})

	return objVal, diags
}

func (v NodeTemplatesValue) Equal(o attr.Value) bool {
	other, ok := o.(NodeTemplatesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Annotations.Equal(other.Annotations) {
		return false
	}

	if !v.Component.Equal(other.Component) {
		return false
	}

	if !v.Labels.Equal(other.Labels) {
		return false
	}

	if !v.License.Equal(other.License) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.NodeProfile.Equal(other.NodeProfile) {
		return false
	}

	if !v.Platform.Equal(other.Platform) {
		return false
	}

	return true
}

func (v NodeTemplatesValue) Type(ctx context.Context) attr.Type {
	return NodeTemplatesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v NodeTemplatesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"annotations": basetypes.MapType{
			ElemType: types.StringType,
		},
		"component": basetypes.ListType{
			ElemType: ComponentValue{}.Type(ctx),
		},
		"labels": basetypes.MapType{
			ElemType: types.StringType,
		},
		"license":      basetypes.StringType{},
		"name":         basetypes.StringType{},
		"node_profile": basetypes.StringType{},
		"platform":     basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ComponentType{}

type ComponentType struct {
	basetypes.ObjectType
}

func (t ComponentType) Equal(o attr.Type) bool {
	other, ok := o.(ComponentType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ComponentType) String() string {
	return "ComponentType"
}

func (t ComponentType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	kindAttribute, ok := attributes["kind"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`kind is missing from object`)

		return nil, diags
	}

	kindVal, ok := kindAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`kind expected to be basetypes.StringValue, was: %T`, kindAttribute))
	}

	slotAttribute, ok := attributes["slot"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`slot is missing from object`)

		return nil, diags
	}

	slotVal, ok := slotAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`slot expected to be basetypes.StringValue, was: %T`, slotAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ComponentValue{
		Kind:          kindVal,
		Slot:          slotVal,
		ComponentType: typeVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewComponentValueNull() ComponentValue {
	return ComponentValue{
		state: attr.ValueStateNull,
	}
}

func NewComponentValueUnknown() ComponentValue {
	return ComponentValue{
		state: attr.ValueStateUnknown,
	}
}

func NewComponentValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ComponentValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ComponentValue Attribute Value",
				"While creating a ComponentValue value, a missing attribute value was detected. "+
					"A ComponentValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ComponentValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ComponentValue Attribute Type",
				"While creating a ComponentValue value, an invalid attribute value was detected. "+
					"A ComponentValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ComponentValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ComponentValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ComponentValue Attribute Value",
				"While creating a ComponentValue value, an extra attribute value was detected. "+
					"A ComponentValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ComponentValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewComponentValueUnknown(), diags
	}

	kindAttribute, ok := attributes["kind"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`kind is missing from object`)

		return NewComponentValueUnknown(), diags
	}

	kindVal, ok := kindAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`kind expected to be basetypes.StringValue, was: %T`, kindAttribute))
	}

	slotAttribute, ok := attributes["slot"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`slot is missing from object`)

		return NewComponentValueUnknown(), diags
	}

	slotVal, ok := slotAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`slot expected to be basetypes.StringValue, was: %T`, slotAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewComponentValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewComponentValueUnknown(), diags
	}

	return ComponentValue{
		Kind:          kindVal,
		Slot:          slotVal,
		ComponentType: typeVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewComponentValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ComponentValue {
	object, diags := NewComponentValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewComponentValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ComponentType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewComponentValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewComponentValueUnknown(), nil
	}

	if in.IsNull() {
		return NewComponentValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewComponentValueMust(ComponentValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ComponentType) ValueType(ctx context.Context) attr.Value {
	return ComponentValue{}
}

var _ basetypes.ObjectValuable = ComponentValue{}

type ComponentValue struct {
	Kind          basetypes.StringValue `tfsdk:"kind"`
	Slot          basetypes.StringValue `tfsdk:"slot"`
	ComponentType basetypes.StringValue `tfsdk:"type"`
	state         attr.ValueState
}

func (v ComponentValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["kind"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["slot"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Kind.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["kind"] = val

		val, err = v.Slot.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["slot"] = val

		val, err = v.ComponentType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ComponentValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ComponentValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ComponentValue) String() string {
	return "ComponentValue"
}

func (v ComponentValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"kind": basetypes.StringType{},
		"slot": basetypes.StringType{},
		"type": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"kind": v.Kind,
			"slot": v.Slot,
			"type": v.ComponentType,
		})

	return objVal, diags
}

func (v ComponentValue) Equal(o attr.Value) bool {
	other, ok := o.(ComponentValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Kind.Equal(other.Kind) {
		return false
	}

	if !v.Slot.Equal(other.Slot) {
		return false
	}

	if !v.ComponentType.Equal(other.ComponentType) {
		return false
	}

	return true
}

func (v ComponentValue) Type(ctx context.Context) attr.Type {
	return ComponentType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ComponentValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"kind": basetypes.StringType{},
		"slot": basetypes.StringType{},
		"type": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = NodesType{}

type NodesType struct {
	basetypes.ObjectType
}

func (t NodesType) Equal(o attr.Type) bool {
	other, ok := o.(NodesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t NodesType) String() string {
	return "NodesType"
}

func (t NodesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	annotationsAttribute, ok := attributes["annotations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`annotations is missing from object`)

		return nil, diags
	}

	annotationsVal, ok := annotationsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`annotations expected to be basetypes.MapValue, was: %T`, annotationsAttribute))
	}

	component1Attribute, ok := attributes["component"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`component_1 is missing from object`)

		return nil, diags
	}

	component1Val, ok := component1Attribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`component_1 expected to be basetypes.ListValue, was: %T`, component1Attribute))
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return nil, diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.MapValue, was: %T`, labelsAttribute))
	}

	licenseAttribute, ok := attributes["license"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`license is missing from object`)

		return nil, diags
	}

	licenseVal, ok := licenseAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`license expected to be basetypes.StringValue, was: %T`, licenseAttribute))
	}

	macAddressAttribute, ok := attributes["mac_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac_address is missing from object`)

		return nil, diags
	}

	macAddressVal, ok := macAddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac_address expected to be basetypes.StringValue, was: %T`, macAddressAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	nodeProfileAttribute, ok := attributes["node_profile"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node_profile is missing from object`)

		return nil, diags
	}

	nodeProfileVal, ok := nodeProfileAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node_profile expected to be basetypes.StringValue, was: %T`, nodeProfileAttribute))
	}

	nppAttribute, ok := attributes["npp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`npp is missing from object`)

		return nil, diags
	}

	nppVal, ok := nppAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`npp expected to be basetypes.ObjectValue, was: %T`, nppAttribute))
	}

	onBoardedAttribute, ok := attributes["on_boarded"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`on_boarded is missing from object`)

		return nil, diags
	}

	onBoardedVal, ok := onBoardedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`on_boarded expected to be basetypes.BoolValue, was: %T`, onBoardedAttribute))
	}

	operatingSystemAttribute, ok := attributes["operating_system"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operating_system is missing from object`)

		return nil, diags
	}

	operatingSystemVal, ok := operatingSystemAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operating_system expected to be basetypes.StringValue, was: %T`, operatingSystemAttribute))
	}

	platformAttribute, ok := attributes["platform"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`platform is missing from object`)

		return nil, diags
	}

	platformVal, ok := platformAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`platform expected to be basetypes.StringValue, was: %T`, platformAttribute))
	}

	productionAddressAttribute, ok := attributes["production_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`production_address is missing from object`)

		return nil, diags
	}

	productionAddressVal, ok := productionAddressAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`production_address expected to be basetypes.ObjectValue, was: %T`, productionAddressAttribute))
	}

	serialNumberAttribute, ok := attributes["serial_number"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`serial_number is missing from object`)

		return nil, diags
	}

	serialNumberVal, ok := serialNumberAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`serial_number expected to be basetypes.StringValue, was: %T`, serialNumberAttribute))
	}

	systemInterfaceAttribute, ok := attributes["system_interface"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`system_interface is missing from object`)

		return nil, diags
	}

	systemInterfaceVal, ok := systemInterfaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`system_interface expected to be basetypes.StringValue, was: %T`, systemInterfaceAttribute))
	}

	templateAttribute, ok := attributes["template"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`template is missing from object`)

		return nil, diags
	}

	templateVal, ok := templateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`template expected to be basetypes.StringValue, was: %T`, templateAttribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return nil, diags
	}

	versionVal, ok := versionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be basetypes.StringValue, was: %T`, versionAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return NodesValue{
		Annotations:       annotationsVal,
		Component1:        component1Val,
		Labels:            labelsVal,
		License:           licenseVal,
		MacAddress:        macAddressVal,
		Name:              nameVal,
		NodeProfile:       nodeProfileVal,
		Npp:               nppVal,
		OnBoarded:         onBoardedVal,
		OperatingSystem:   operatingSystemVal,
		Platform:          platformVal,
		ProductionAddress: productionAddressVal,
		SerialNumber:      serialNumberVal,
		SystemInterface:   systemInterfaceVal,
		Template:          templateVal,
		Version:           versionVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewNodesValueNull() NodesValue {
	return NodesValue{
		state: attr.ValueStateNull,
	}
}

func NewNodesValueUnknown() NodesValue {
	return NodesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewNodesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (NodesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing NodesValue Attribute Value",
				"While creating a NodesValue value, a missing attribute value was detected. "+
					"A NodesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NodesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid NodesValue Attribute Type",
				"While creating a NodesValue value, an invalid attribute value was detected. "+
					"A NodesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NodesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("NodesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra NodesValue Attribute Value",
				"While creating a NodesValue value, an extra attribute value was detected. "+
					"A NodesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra NodesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewNodesValueUnknown(), diags
	}

	annotationsAttribute, ok := attributes["annotations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`annotations is missing from object`)

		return NewNodesValueUnknown(), diags
	}

	annotationsVal, ok := annotationsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`annotations expected to be basetypes.MapValue, was: %T`, annotationsAttribute))
	}

	component1Attribute, ok := attributes["component"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`component_1 is missing from object`)

		return NewNodesValueUnknown(), diags
	}

	component1Val, ok := component1Attribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`component_1 expected to be basetypes.ListValue, was: %T`, component1Attribute))
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return NewNodesValueUnknown(), diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.MapValue, was: %T`, labelsAttribute))
	}

	licenseAttribute, ok := attributes["license"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`license is missing from object`)

		return NewNodesValueUnknown(), diags
	}

	licenseVal, ok := licenseAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`license expected to be basetypes.StringValue, was: %T`, licenseAttribute))
	}

	macAddressAttribute, ok := attributes["mac_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac_address is missing from object`)

		return NewNodesValueUnknown(), diags
	}

	macAddressVal, ok := macAddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac_address expected to be basetypes.StringValue, was: %T`, macAddressAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewNodesValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	nodeProfileAttribute, ok := attributes["node_profile"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node_profile is missing from object`)

		return NewNodesValueUnknown(), diags
	}

	nodeProfileVal, ok := nodeProfileAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node_profile expected to be basetypes.StringValue, was: %T`, nodeProfileAttribute))
	}

	nppAttribute, ok := attributes["npp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`npp is missing from object`)

		return NewNodesValueUnknown(), diags
	}

	nppVal, ok := nppAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`npp expected to be basetypes.ObjectValue, was: %T`, nppAttribute))
	}

	onBoardedAttribute, ok := attributes["on_boarded"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`on_boarded is missing from object`)

		return NewNodesValueUnknown(), diags
	}

	onBoardedVal, ok := onBoardedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`on_boarded expected to be basetypes.BoolValue, was: %T`, onBoardedAttribute))
	}

	operatingSystemAttribute, ok := attributes["operating_system"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operating_system is missing from object`)

		return NewNodesValueUnknown(), diags
	}

	operatingSystemVal, ok := operatingSystemAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operating_system expected to be basetypes.StringValue, was: %T`, operatingSystemAttribute))
	}

	platformAttribute, ok := attributes["platform"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`platform is missing from object`)

		return NewNodesValueUnknown(), diags
	}

	platformVal, ok := platformAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`platform expected to be basetypes.StringValue, was: %T`, platformAttribute))
	}

	productionAddressAttribute, ok := attributes["production_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`production_address is missing from object`)

		return NewNodesValueUnknown(), diags
	}

	productionAddressVal, ok := productionAddressAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`production_address expected to be basetypes.ObjectValue, was: %T`, productionAddressAttribute))
	}

	serialNumberAttribute, ok := attributes["serial_number"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`serial_number is missing from object`)

		return NewNodesValueUnknown(), diags
	}

	serialNumberVal, ok := serialNumberAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`serial_number expected to be basetypes.StringValue, was: %T`, serialNumberAttribute))
	}

	systemInterfaceAttribute, ok := attributes["system_interface"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`system_interface is missing from object`)

		return NewNodesValueUnknown(), diags
	}

	systemInterfaceVal, ok := systemInterfaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`system_interface expected to be basetypes.StringValue, was: %T`, systemInterfaceAttribute))
	}

	templateAttribute, ok := attributes["template"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`template is missing from object`)

		return NewNodesValueUnknown(), diags
	}

	templateVal, ok := templateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`template expected to be basetypes.StringValue, was: %T`, templateAttribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return NewNodesValueUnknown(), diags
	}

	versionVal, ok := versionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be basetypes.StringValue, was: %T`, versionAttribute))
	}

	if diags.HasError() {
		return NewNodesValueUnknown(), diags
	}

	return NodesValue{
		Annotations:       annotationsVal,
		Component1:        component1Val,
		Labels:            labelsVal,
		License:           licenseVal,
		MacAddress:        macAddressVal,
		Name:              nameVal,
		NodeProfile:       nodeProfileVal,
		Npp:               nppVal,
		OnBoarded:         onBoardedVal,
		OperatingSystem:   operatingSystemVal,
		Platform:          platformVal,
		ProductionAddress: productionAddressVal,
		SerialNumber:      serialNumberVal,
		SystemInterface:   systemInterfaceVal,
		Template:          templateVal,
		Version:           versionVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewNodesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) NodesValue {
	object, diags := NewNodesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewNodesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t NodesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewNodesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewNodesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewNodesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewNodesValueMust(NodesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t NodesType) ValueType(ctx context.Context) attr.Value {
	return NodesValue{}
}

var _ basetypes.ObjectValuable = NodesValue{}

type NodesValue struct {
	Annotations       basetypes.MapValue    `tfsdk:"annotations"`
	Component1        basetypes.ListValue   `tfsdk:"component"`
	Labels            basetypes.MapValue    `tfsdk:"labels"`
	License           basetypes.StringValue `tfsdk:"license"`
	MacAddress        basetypes.StringValue `tfsdk:"mac_address"`
	Name              basetypes.StringValue `tfsdk:"name"`
	NodeProfile       basetypes.StringValue `tfsdk:"node_profile"`
	Npp               basetypes.ObjectValue `tfsdk:"npp"`
	OnBoarded         basetypes.BoolValue   `tfsdk:"on_boarded"`
	OperatingSystem   basetypes.StringValue `tfsdk:"operating_system"`
	Platform          basetypes.StringValue `tfsdk:"platform"`
	ProductionAddress basetypes.ObjectValue `tfsdk:"production_address"`
	SerialNumber      basetypes.StringValue `tfsdk:"serial_number"`
	SystemInterface   basetypes.StringValue `tfsdk:"system_interface"`
	Template          basetypes.StringValue `tfsdk:"template"`
	Version           basetypes.StringValue `tfsdk:"version"`
	state             attr.ValueState
}

func (v NodesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 16)

	var val tftypes.Value
	var err error

	attrTypes["annotations"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["component"] = basetypes.ListType{
		ElemType: Component1Value{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["labels"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["license"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["mac_address"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["node_profile"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["npp"] = basetypes.ObjectType{
		AttrTypes: NppValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["on_boarded"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["operating_system"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["platform"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["production_address"] = basetypes.ObjectType{
		AttrTypes: ProductionAddressValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["serial_number"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["system_interface"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["template"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["version"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 16)

		val, err = v.Annotations.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["annotations"] = val

		val, err = v.Component1.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["component"] = val

		val, err = v.Labels.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["labels"] = val

		val, err = v.License.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["license"] = val

		val, err = v.MacAddress.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mac_address"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.NodeProfile.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["node_profile"] = val

		val, err = v.Npp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["npp"] = val

		val, err = v.OnBoarded.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["on_boarded"] = val

		val, err = v.OperatingSystem.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["operating_system"] = val

		val, err = v.Platform.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["platform"] = val

		val, err = v.ProductionAddress.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["production_address"] = val

		val, err = v.SerialNumber.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["serial_number"] = val

		val, err = v.SystemInterface.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["system_interface"] = val

		val, err = v.Template.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["template"] = val

		val, err = v.Version.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["version"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v NodesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v NodesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v NodesValue) String() string {
	return "NodesValue"
}

func (v NodesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	component1 := types.ListValueMust(
		Component1Type{
			basetypes.ObjectType{
				AttrTypes: Component1Value{}.AttributeTypes(ctx),
			},
		},
		v.Component1.Elements(),
	)

	if v.Component1.IsNull() {
		component1 = types.ListNull(
			Component1Type{
				basetypes.ObjectType{
					AttrTypes: Component1Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Component1.IsUnknown() {
		component1 = types.ListUnknown(
			Component1Type{
				basetypes.ObjectType{
					AttrTypes: Component1Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var npp basetypes.ObjectValue

	if v.Npp.IsNull() {
		npp = types.ObjectNull(
			NppValue{}.AttributeTypes(ctx),
		)
	}

	if v.Npp.IsUnknown() {
		npp = types.ObjectUnknown(
			NppValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Npp.IsNull() && !v.Npp.IsUnknown() {
		npp = types.ObjectValueMust(
			NppValue{}.AttributeTypes(ctx),
			v.Npp.Attributes(),
		)
	}

	var productionAddress basetypes.ObjectValue

	if v.ProductionAddress.IsNull() {
		productionAddress = types.ObjectNull(
			ProductionAddressValue{}.AttributeTypes(ctx),
		)
	}

	if v.ProductionAddress.IsUnknown() {
		productionAddress = types.ObjectUnknown(
			ProductionAddressValue{}.AttributeTypes(ctx),
		)
	}

	if !v.ProductionAddress.IsNull() && !v.ProductionAddress.IsUnknown() {
		productionAddress = types.ObjectValueMust(
			ProductionAddressValue{}.AttributeTypes(ctx),
			v.ProductionAddress.Attributes(),
		)
	}

	var annotationsVal basetypes.MapValue
	switch {
	case v.Annotations.IsUnknown():
		annotationsVal = types.MapUnknown(types.StringType)
	case v.Annotations.IsNull():
		annotationsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		annotationsVal, d = types.MapValue(types.StringType, v.Annotations.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"annotations": basetypes.MapType{
				ElemType: types.StringType,
			},
			"component": basetypes.ListType{
				ElemType: Component1Value{}.Type(ctx),
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"license":      basetypes.StringType{},
			"mac_address":  basetypes.StringType{},
			"name":         basetypes.StringType{},
			"node_profile": basetypes.StringType{},
			"npp": basetypes.ObjectType{
				AttrTypes: NppValue{}.AttributeTypes(ctx),
			},
			"on_boarded":       basetypes.BoolType{},
			"operating_system": basetypes.StringType{},
			"platform":         basetypes.StringType{},
			"production_address": basetypes.ObjectType{
				AttrTypes: ProductionAddressValue{}.AttributeTypes(ctx),
			},
			"serial_number":    basetypes.StringType{},
			"system_interface": basetypes.StringType{},
			"template":         basetypes.StringType{},
			"version":          basetypes.StringType{},
		}), diags
	}

	var labelsVal basetypes.MapValue
	switch {
	case v.Labels.IsUnknown():
		labelsVal = types.MapUnknown(types.StringType)
	case v.Labels.IsNull():
		labelsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		labelsVal, d = types.MapValue(types.StringType, v.Labels.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"annotations": basetypes.MapType{
				ElemType: types.StringType,
			},
			"component": basetypes.ListType{
				ElemType: Component1Value{}.Type(ctx),
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"license":      basetypes.StringType{},
			"mac_address":  basetypes.StringType{},
			"name":         basetypes.StringType{},
			"node_profile": basetypes.StringType{},
			"npp": basetypes.ObjectType{
				AttrTypes: NppValue{}.AttributeTypes(ctx),
			},
			"on_boarded":       basetypes.BoolType{},
			"operating_system": basetypes.StringType{},
			"platform":         basetypes.StringType{},
			"production_address": basetypes.ObjectType{
				AttrTypes: ProductionAddressValue{}.AttributeTypes(ctx),
			},
			"serial_number":    basetypes.StringType{},
			"system_interface": basetypes.StringType{},
			"template":         basetypes.StringType{},
			"version":          basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"annotations": basetypes.MapType{
			ElemType: types.StringType,
		},
		"component": basetypes.ListType{
			ElemType: Component1Value{}.Type(ctx),
		},
		"labels": basetypes.MapType{
			ElemType: types.StringType,
		},
		"license":      basetypes.StringType{},
		"mac_address":  basetypes.StringType{},
		"name":         basetypes.StringType{},
		"node_profile": basetypes.StringType{},
		"npp": basetypes.ObjectType{
			AttrTypes: NppValue{}.AttributeTypes(ctx),
		},
		"on_boarded":       basetypes.BoolType{},
		"operating_system": basetypes.StringType{},
		"platform":         basetypes.StringType{},
		"production_address": basetypes.ObjectType{
			AttrTypes: ProductionAddressValue{}.AttributeTypes(ctx),
		},
		"serial_number":    basetypes.StringType{},
		"system_interface": basetypes.StringType{},
		"template":         basetypes.StringType{},
		"version":          basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"annotations":        annotationsVal,
			"component":          component1,
			"labels":             labelsVal,
			"license":            v.License,
			"mac_address":        v.MacAddress,
			"name":               v.Name,
			"node_profile":       v.NodeProfile,
			"npp":                npp,
			"on_boarded":         v.OnBoarded,
			"operating_system":   v.OperatingSystem,
			"platform":           v.Platform,
			"production_address": productionAddress,
			"serial_number":      v.SerialNumber,
			"system_interface":   v.SystemInterface,
			"template":           v.Template,
			"version":            v.Version,
		})

	return objVal, diags
}

func (v NodesValue) Equal(o attr.Value) bool {
	other, ok := o.(NodesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Annotations.Equal(other.Annotations) {
		return false
	}

	if !v.Component1.Equal(other.Component1) {
		return false
	}

	if !v.Labels.Equal(other.Labels) {
		return false
	}

	if !v.License.Equal(other.License) {
		return false
	}

	if !v.MacAddress.Equal(other.MacAddress) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.NodeProfile.Equal(other.NodeProfile) {
		return false
	}

	if !v.Npp.Equal(other.Npp) {
		return false
	}

	if !v.OnBoarded.Equal(other.OnBoarded) {
		return false
	}

	if !v.OperatingSystem.Equal(other.OperatingSystem) {
		return false
	}

	if !v.Platform.Equal(other.Platform) {
		return false
	}

	if !v.ProductionAddress.Equal(other.ProductionAddress) {
		return false
	}

	if !v.SerialNumber.Equal(other.SerialNumber) {
		return false
	}

	if !v.SystemInterface.Equal(other.SystemInterface) {
		return false
	}

	if !v.Template.Equal(other.Template) {
		return false
	}

	if !v.Version.Equal(other.Version) {
		return false
	}

	return true
}

func (v NodesValue) Type(ctx context.Context) attr.Type {
	return NodesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v NodesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"annotations": basetypes.MapType{
			ElemType: types.StringType,
		},
		"component": basetypes.ListType{
			ElemType: Component1Value{}.Type(ctx),
		},
		"labels": basetypes.MapType{
			ElemType: types.StringType,
		},
		"license":      basetypes.StringType{},
		"mac_address":  basetypes.StringType{},
		"name":         basetypes.StringType{},
		"node_profile": basetypes.StringType{},
		"npp": basetypes.ObjectType{
			AttrTypes: NppValue{}.AttributeTypes(ctx),
		},
		"on_boarded":       basetypes.BoolType{},
		"operating_system": basetypes.StringType{},
		"platform":         basetypes.StringType{},
		"production_address": basetypes.ObjectType{
			AttrTypes: ProductionAddressValue{}.AttributeTypes(ctx),
		},
		"serial_number":    basetypes.StringType{},
		"system_interface": basetypes.StringType{},
		"template":         basetypes.StringType{},
		"version":          basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = Component1Type{}

type Component1Type struct {
	basetypes.ObjectType
}

func (t Component1Type) Equal(o attr.Type) bool {
	other, ok := o.(Component1Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Component1Type) String() string {
	return "Component1Type"
}

func (t Component1Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	kindAttribute, ok := attributes["kind"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`kind is missing from object`)

		return nil, diags
	}

	kindVal, ok := kindAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`kind expected to be basetypes.StringValue, was: %T`, kindAttribute))
	}

	slotAttribute, ok := attributes["slot"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`slot is missing from object`)

		return nil, diags
	}

	slotVal, ok := slotAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`slot expected to be basetypes.StringValue, was: %T`, slotAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Component1Value{
		Kind:           kindVal,
		Slot:           slotVal,
		Component1Type: typeVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewComponent1ValueNull() Component1Value {
	return Component1Value{
		state: attr.ValueStateNull,
	}
}

func NewComponent1ValueUnknown() Component1Value {
	return Component1Value{
		state: attr.ValueStateUnknown,
	}
}

func NewComponent1Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Component1Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Component1Value Attribute Value",
				"While creating a Component1Value value, a missing attribute value was detected. "+
					"A Component1Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Component1Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Component1Value Attribute Type",
				"While creating a Component1Value value, an invalid attribute value was detected. "+
					"A Component1Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Component1Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Component1Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Component1Value Attribute Value",
				"While creating a Component1Value value, an extra attribute value was detected. "+
					"A Component1Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Component1Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewComponent1ValueUnknown(), diags
	}

	kindAttribute, ok := attributes["kind"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`kind is missing from object`)

		return NewComponent1ValueUnknown(), diags
	}

	kindVal, ok := kindAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`kind expected to be basetypes.StringValue, was: %T`, kindAttribute))
	}

	slotAttribute, ok := attributes["slot"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`slot is missing from object`)

		return NewComponent1ValueUnknown(), diags
	}

	slotVal, ok := slotAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`slot expected to be basetypes.StringValue, was: %T`, slotAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewComponent1ValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewComponent1ValueUnknown(), diags
	}

	return Component1Value{
		Kind:           kindVal,
		Slot:           slotVal,
		Component1Type: typeVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewComponent1ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Component1Value {
	object, diags := NewComponent1Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewComponent1ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Component1Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewComponent1ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewComponent1ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewComponent1ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewComponent1ValueMust(Component1Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Component1Type) ValueType(ctx context.Context) attr.Value {
	return Component1Value{}
}

var _ basetypes.ObjectValuable = Component1Value{}

type Component1Value struct {
	Kind           basetypes.StringValue `tfsdk:"kind"`
	Slot           basetypes.StringValue `tfsdk:"slot"`
	Component1Type basetypes.StringValue `tfsdk:"type"`
	state          attr.ValueState
}

func (v Component1Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["kind"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["slot"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Kind.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["kind"] = val

		val, err = v.Slot.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["slot"] = val

		val, err = v.Component1Type.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Component1Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Component1Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Component1Value) String() string {
	return "Component1Value"
}

func (v Component1Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"kind": basetypes.StringType{},
		"slot": basetypes.StringType{},
		"type": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"kind": v.Kind,
			"slot": v.Slot,
			"type": v.Component1Type,
		})

	return objVal, diags
}

func (v Component1Value) Equal(o attr.Value) bool {
	other, ok := o.(Component1Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Kind.Equal(other.Kind) {
		return false
	}

	if !v.Slot.Equal(other.Slot) {
		return false
	}

	if !v.Component1Type.Equal(other.Component1Type) {
		return false
	}

	return true
}

func (v Component1Value) Type(ctx context.Context) attr.Type {
	return Component1Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Component1Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"kind": basetypes.StringType{},
		"slot": basetypes.StringType{},
		"type": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = NppType{}

type NppType struct {
	basetypes.ObjectType
}

func (t NppType) Equal(o attr.Type) bool {
	other, ok := o.(NppType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t NppType) String() string {
	return "NppType"
}

func (t NppType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	modeAttribute, ok := attributes["mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mode is missing from object`)

		return nil, diags
	}

	modeVal, ok := modeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mode expected to be basetypes.StringValue, was: %T`, modeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return NppValue{
		Mode:  modeVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewNppValueNull() NppValue {
	return NppValue{
		state: attr.ValueStateNull,
	}
}

func NewNppValueUnknown() NppValue {
	return NppValue{
		state: attr.ValueStateUnknown,
	}
}

func NewNppValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (NppValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing NppValue Attribute Value",
				"While creating a NppValue value, a missing attribute value was detected. "+
					"A NppValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NppValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid NppValue Attribute Type",
				"While creating a NppValue value, an invalid attribute value was detected. "+
					"A NppValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NppValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("NppValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra NppValue Attribute Value",
				"While creating a NppValue value, an extra attribute value was detected. "+
					"A NppValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra NppValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewNppValueUnknown(), diags
	}

	modeAttribute, ok := attributes["mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mode is missing from object`)

		return NewNppValueUnknown(), diags
	}

	modeVal, ok := modeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mode expected to be basetypes.StringValue, was: %T`, modeAttribute))
	}

	if diags.HasError() {
		return NewNppValueUnknown(), diags
	}

	return NppValue{
		Mode:  modeVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewNppValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) NppValue {
	object, diags := NewNppValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewNppValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t NppType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewNppValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewNppValueUnknown(), nil
	}

	if in.IsNull() {
		return NewNppValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewNppValueMust(NppValue{}.AttributeTypes(ctx), attributes), nil
}

func (t NppType) ValueType(ctx context.Context) attr.Value {
	return NppValue{}
}

var _ basetypes.ObjectValuable = NppValue{}

type NppValue struct {
	Mode  basetypes.StringValue `tfsdk:"mode"`
	state attr.ValueState
}

func (v NppValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["mode"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Mode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mode"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v NppValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v NppValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v NppValue) String() string {
	return "NppValue"
}

func (v NppValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"mode": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"mode": v.Mode,
		})

	return objVal, diags
}

func (v NppValue) Equal(o attr.Value) bool {
	other, ok := o.(NppValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Mode.Equal(other.Mode) {
		return false
	}

	return true
}

func (v NppValue) Type(ctx context.Context) attr.Type {
	return NppType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v NppValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"mode": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ProductionAddressType{}

type ProductionAddressType struct {
	basetypes.ObjectType
}

func (t ProductionAddressType) Equal(o attr.Type) bool {
	other, ok := o.(ProductionAddressType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ProductionAddressType) String() string {
	return "ProductionAddressType"
}

func (t ProductionAddressType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	ipv4Attribute, ok := attributes["ipv4"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv4 is missing from object`)

		return nil, diags
	}

	ipv4Val, ok := ipv4Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv4 expected to be basetypes.StringValue, was: %T`, ipv4Attribute))
	}

	ipv6Attribute, ok := attributes["ipv6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv6 is missing from object`)

		return nil, diags
	}

	ipv6Val, ok := ipv6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv6 expected to be basetypes.StringValue, was: %T`, ipv6Attribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ProductionAddressValue{
		Ipv4:  ipv4Val,
		Ipv6:  ipv6Val,
		state: attr.ValueStateKnown,
	}, diags
}

func NewProductionAddressValueNull() ProductionAddressValue {
	return ProductionAddressValue{
		state: attr.ValueStateNull,
	}
}

func NewProductionAddressValueUnknown() ProductionAddressValue {
	return ProductionAddressValue{
		state: attr.ValueStateUnknown,
	}
}

func NewProductionAddressValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ProductionAddressValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ProductionAddressValue Attribute Value",
				"While creating a ProductionAddressValue value, a missing attribute value was detected. "+
					"A ProductionAddressValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ProductionAddressValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ProductionAddressValue Attribute Type",
				"While creating a ProductionAddressValue value, an invalid attribute value was detected. "+
					"A ProductionAddressValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ProductionAddressValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ProductionAddressValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ProductionAddressValue Attribute Value",
				"While creating a ProductionAddressValue value, an extra attribute value was detected. "+
					"A ProductionAddressValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ProductionAddressValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewProductionAddressValueUnknown(), diags
	}

	ipv4Attribute, ok := attributes["ipv4"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv4 is missing from object`)

		return NewProductionAddressValueUnknown(), diags
	}

	ipv4Val, ok := ipv4Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv4 expected to be basetypes.StringValue, was: %T`, ipv4Attribute))
	}

	ipv6Attribute, ok := attributes["ipv6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv6 is missing from object`)

		return NewProductionAddressValueUnknown(), diags
	}

	ipv6Val, ok := ipv6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv6 expected to be basetypes.StringValue, was: %T`, ipv6Attribute))
	}

	if diags.HasError() {
		return NewProductionAddressValueUnknown(), diags
	}

	return ProductionAddressValue{
		Ipv4:  ipv4Val,
		Ipv6:  ipv6Val,
		state: attr.ValueStateKnown,
	}, diags
}

func NewProductionAddressValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ProductionAddressValue {
	object, diags := NewProductionAddressValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewProductionAddressValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ProductionAddressType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewProductionAddressValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewProductionAddressValueUnknown(), nil
	}

	if in.IsNull() {
		return NewProductionAddressValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewProductionAddressValueMust(ProductionAddressValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ProductionAddressType) ValueType(ctx context.Context) attr.Value {
	return ProductionAddressValue{}
}

var _ basetypes.ObjectValuable = ProductionAddressValue{}

type ProductionAddressValue struct {
	Ipv4  basetypes.StringValue `tfsdk:"ipv4"`
	Ipv6  basetypes.StringValue `tfsdk:"ipv6"`
	state attr.ValueState
}

func (v ProductionAddressValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["ipv4"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ipv6"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Ipv4.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ipv4"] = val

		val, err = v.Ipv6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ipv6"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ProductionAddressValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ProductionAddressValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ProductionAddressValue) String() string {
	return "ProductionAddressValue"
}

func (v ProductionAddressValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"ipv4": basetypes.StringType{},
		"ipv6": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"ipv4": v.Ipv4,
			"ipv6": v.Ipv6,
		})

	return objVal, diags
}

func (v ProductionAddressValue) Equal(o attr.Value) bool {
	other, ok := o.(ProductionAddressValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Ipv4.Equal(other.Ipv4) {
		return false
	}

	if !v.Ipv6.Equal(other.Ipv6) {
		return false
	}

	return true
}

func (v ProductionAddressValue) Type(ctx context.Context) attr.Type {
	return ProductionAddressType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ProductionAddressValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"ipv4": basetypes.StringType{},
		"ipv6": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = SimulationType{}

type SimulationType struct {
	basetypes.ObjectType
}

func (t SimulationType) Equal(o attr.Type) bool {
	other, ok := o.(SimulationType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SimulationType) String() string {
	return "SimulationType"
}

func (t SimulationType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	simNodeTemplatesAttribute, ok := attributes["sim_node_templates"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sim_node_templates is missing from object`)

		return nil, diags
	}

	simNodeTemplatesVal, ok := simNodeTemplatesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sim_node_templates expected to be basetypes.ListValue, was: %T`, simNodeTemplatesAttribute))
	}

	simNodesAttribute, ok := attributes["sim_nodes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sim_nodes is missing from object`)

		return nil, diags
	}

	simNodesVal, ok := simNodesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sim_nodes expected to be basetypes.ListValue, was: %T`, simNodesAttribute))
	}

	topologyAttribute, ok := attributes["topology"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`topology is missing from object`)

		return nil, diags
	}

	topologyVal, ok := topologyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`topology expected to be basetypes.ListValue, was: %T`, topologyAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SimulationValue{
		SimNodeTemplates: simNodeTemplatesVal,
		SimNodes:         simNodesVal,
		Topology:         topologyVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewSimulationValueNull() SimulationValue {
	return SimulationValue{
		state: attr.ValueStateNull,
	}
}

func NewSimulationValueUnknown() SimulationValue {
	return SimulationValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSimulationValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SimulationValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SimulationValue Attribute Value",
				"While creating a SimulationValue value, a missing attribute value was detected. "+
					"A SimulationValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SimulationValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SimulationValue Attribute Type",
				"While creating a SimulationValue value, an invalid attribute value was detected. "+
					"A SimulationValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SimulationValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SimulationValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SimulationValue Attribute Value",
				"While creating a SimulationValue value, an extra attribute value was detected. "+
					"A SimulationValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SimulationValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSimulationValueUnknown(), diags
	}

	simNodeTemplatesAttribute, ok := attributes["sim_node_templates"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sim_node_templates is missing from object`)

		return NewSimulationValueUnknown(), diags
	}

	simNodeTemplatesVal, ok := simNodeTemplatesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sim_node_templates expected to be basetypes.ListValue, was: %T`, simNodeTemplatesAttribute))
	}

	simNodesAttribute, ok := attributes["sim_nodes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sim_nodes is missing from object`)

		return NewSimulationValueUnknown(), diags
	}

	simNodesVal, ok := simNodesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sim_nodes expected to be basetypes.ListValue, was: %T`, simNodesAttribute))
	}

	topologyAttribute, ok := attributes["topology"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`topology is missing from object`)

		return NewSimulationValueUnknown(), diags
	}

	topologyVal, ok := topologyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`topology expected to be basetypes.ListValue, was: %T`, topologyAttribute))
	}

	if diags.HasError() {
		return NewSimulationValueUnknown(), diags
	}

	return SimulationValue{
		SimNodeTemplates: simNodeTemplatesVal,
		SimNodes:         simNodesVal,
		Topology:         topologyVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewSimulationValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SimulationValue {
	object, diags := NewSimulationValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSimulationValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SimulationType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSimulationValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSimulationValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSimulationValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSimulationValueMust(SimulationValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SimulationType) ValueType(ctx context.Context) attr.Value {
	return SimulationValue{}
}

var _ basetypes.ObjectValuable = SimulationValue{}

type SimulationValue struct {
	SimNodeTemplates basetypes.ListValue `tfsdk:"sim_node_templates"`
	SimNodes         basetypes.ListValue `tfsdk:"sim_nodes"`
	Topology         basetypes.ListValue `tfsdk:"topology"`
	state            attr.ValueState
}

func (v SimulationValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["sim_node_templates"] = basetypes.ListType{
		ElemType: SimNodeTemplatesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["sim_nodes"] = basetypes.ListType{
		ElemType: SimNodesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["topology"] = basetypes.ListType{
		ElemType: TopologyValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.SimNodeTemplates.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sim_node_templates"] = val

		val, err = v.SimNodes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sim_nodes"] = val

		val, err = v.Topology.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["topology"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SimulationValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SimulationValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SimulationValue) String() string {
	return "SimulationValue"
}

func (v SimulationValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	simNodeTemplates := types.ListValueMust(
		SimNodeTemplatesType{
			basetypes.ObjectType{
				AttrTypes: SimNodeTemplatesValue{}.AttributeTypes(ctx),
			},
		},
		v.SimNodeTemplates.Elements(),
	)

	if v.SimNodeTemplates.IsNull() {
		simNodeTemplates = types.ListNull(
			SimNodeTemplatesType{
				basetypes.ObjectType{
					AttrTypes: SimNodeTemplatesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.SimNodeTemplates.IsUnknown() {
		simNodeTemplates = types.ListUnknown(
			SimNodeTemplatesType{
				basetypes.ObjectType{
					AttrTypes: SimNodeTemplatesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	simNodes := types.ListValueMust(
		SimNodesType{
			basetypes.ObjectType{
				AttrTypes: SimNodesValue{}.AttributeTypes(ctx),
			},
		},
		v.SimNodes.Elements(),
	)

	if v.SimNodes.IsNull() {
		simNodes = types.ListNull(
			SimNodesType{
				basetypes.ObjectType{
					AttrTypes: SimNodesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.SimNodes.IsUnknown() {
		simNodes = types.ListUnknown(
			SimNodesType{
				basetypes.ObjectType{
					AttrTypes: SimNodesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	topology := types.ListValueMust(
		TopologyType{
			basetypes.ObjectType{
				AttrTypes: TopologyValue{}.AttributeTypes(ctx),
			},
		},
		v.Topology.Elements(),
	)

	if v.Topology.IsNull() {
		topology = types.ListNull(
			TopologyType{
				basetypes.ObjectType{
					AttrTypes: TopologyValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Topology.IsUnknown() {
		topology = types.ListUnknown(
			TopologyType{
				basetypes.ObjectType{
					AttrTypes: TopologyValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"sim_node_templates": basetypes.ListType{
			ElemType: SimNodeTemplatesValue{}.Type(ctx),
		},
		"sim_nodes": basetypes.ListType{
			ElemType: SimNodesValue{}.Type(ctx),
		},
		"topology": basetypes.ListType{
			ElemType: TopologyValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"sim_node_templates": simNodeTemplates,
			"sim_nodes":          simNodes,
			"topology":           topology,
		})

	return objVal, diags
}

func (v SimulationValue) Equal(o attr.Value) bool {
	other, ok := o.(SimulationValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.SimNodeTemplates.Equal(other.SimNodeTemplates) {
		return false
	}

	if !v.SimNodes.Equal(other.SimNodes) {
		return false
	}

	if !v.Topology.Equal(other.Topology) {
		return false
	}

	return true
}

func (v SimulationValue) Type(ctx context.Context) attr.Type {
	return SimulationType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SimulationValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"sim_node_templates": basetypes.ListType{
			ElemType: SimNodeTemplatesValue{}.Type(ctx),
		},
		"sim_nodes": basetypes.ListType{
			ElemType: SimNodesValue{}.Type(ctx),
		},
		"topology": basetypes.ListType{
			ElemType: TopologyValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = SimNodeTemplatesType{}

type SimNodeTemplatesType struct {
	basetypes.ObjectType
}

func (t SimNodeTemplatesType) Equal(o attr.Type) bool {
	other, ok := o.(SimNodeTemplatesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SimNodeTemplatesType) String() string {
	return "SimNodeTemplatesType"
}

func (t SimNodeTemplatesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	imageAttribute, ok := attributes["image"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`image is missing from object`)

		return nil, diags
	}

	imageVal, ok := imageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`image expected to be basetypes.StringValue, was: %T`, imageAttribute))
	}

	imagePullSecretAttribute, ok := attributes["image_pull_secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`image_pull_secret is missing from object`)

		return nil, diags
	}

	imagePullSecretVal, ok := imagePullSecretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`image_pull_secret expected to be basetypes.StringValue, was: %T`, imagePullSecretAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SimNodeTemplatesValue{
		Image:                imageVal,
		ImagePullSecret:      imagePullSecretVal,
		Name:                 nameVal,
		SimNodeTemplatesType: typeVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewSimNodeTemplatesValueNull() SimNodeTemplatesValue {
	return SimNodeTemplatesValue{
		state: attr.ValueStateNull,
	}
}

func NewSimNodeTemplatesValueUnknown() SimNodeTemplatesValue {
	return SimNodeTemplatesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSimNodeTemplatesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SimNodeTemplatesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SimNodeTemplatesValue Attribute Value",
				"While creating a SimNodeTemplatesValue value, a missing attribute value was detected. "+
					"A SimNodeTemplatesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SimNodeTemplatesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SimNodeTemplatesValue Attribute Type",
				"While creating a SimNodeTemplatesValue value, an invalid attribute value was detected. "+
					"A SimNodeTemplatesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SimNodeTemplatesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SimNodeTemplatesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SimNodeTemplatesValue Attribute Value",
				"While creating a SimNodeTemplatesValue value, an extra attribute value was detected. "+
					"A SimNodeTemplatesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SimNodeTemplatesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSimNodeTemplatesValueUnknown(), diags
	}

	imageAttribute, ok := attributes["image"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`image is missing from object`)

		return NewSimNodeTemplatesValueUnknown(), diags
	}

	imageVal, ok := imageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`image expected to be basetypes.StringValue, was: %T`, imageAttribute))
	}

	imagePullSecretAttribute, ok := attributes["image_pull_secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`image_pull_secret is missing from object`)

		return NewSimNodeTemplatesValueUnknown(), diags
	}

	imagePullSecretVal, ok := imagePullSecretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`image_pull_secret expected to be basetypes.StringValue, was: %T`, imagePullSecretAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewSimNodeTemplatesValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewSimNodeTemplatesValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewSimNodeTemplatesValueUnknown(), diags
	}

	return SimNodeTemplatesValue{
		Image:                imageVal,
		ImagePullSecret:      imagePullSecretVal,
		Name:                 nameVal,
		SimNodeTemplatesType: typeVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewSimNodeTemplatesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SimNodeTemplatesValue {
	object, diags := NewSimNodeTemplatesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSimNodeTemplatesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SimNodeTemplatesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSimNodeTemplatesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSimNodeTemplatesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSimNodeTemplatesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSimNodeTemplatesValueMust(SimNodeTemplatesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SimNodeTemplatesType) ValueType(ctx context.Context) attr.Value {
	return SimNodeTemplatesValue{}
}

var _ basetypes.ObjectValuable = SimNodeTemplatesValue{}

type SimNodeTemplatesValue struct {
	Image                basetypes.StringValue `tfsdk:"image"`
	ImagePullSecret      basetypes.StringValue `tfsdk:"image_pull_secret"`
	Name                 basetypes.StringValue `tfsdk:"name"`
	SimNodeTemplatesType basetypes.StringValue `tfsdk:"type"`
	state                attr.ValueState
}

func (v SimNodeTemplatesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["image"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["image_pull_secret"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Image.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["image"] = val

		val, err = v.ImagePullSecret.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["image_pull_secret"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.SimNodeTemplatesType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SimNodeTemplatesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SimNodeTemplatesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SimNodeTemplatesValue) String() string {
	return "SimNodeTemplatesValue"
}

func (v SimNodeTemplatesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"image":             basetypes.StringType{},
		"image_pull_secret": basetypes.StringType{},
		"name":              basetypes.StringType{},
		"type":              basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"image":             v.Image,
			"image_pull_secret": v.ImagePullSecret,
			"name":              v.Name,
			"type":              v.SimNodeTemplatesType,
		})

	return objVal, diags
}

func (v SimNodeTemplatesValue) Equal(o attr.Value) bool {
	other, ok := o.(SimNodeTemplatesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Image.Equal(other.Image) {
		return false
	}

	if !v.ImagePullSecret.Equal(other.ImagePullSecret) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.SimNodeTemplatesType.Equal(other.SimNodeTemplatesType) {
		return false
	}

	return true
}

func (v SimNodeTemplatesValue) Type(ctx context.Context) attr.Type {
	return SimNodeTemplatesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SimNodeTemplatesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"image":             basetypes.StringType{},
		"image_pull_secret": basetypes.StringType{},
		"name":              basetypes.StringType{},
		"type":              basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = SimNodesType{}

type SimNodesType struct {
	basetypes.ObjectType
}

func (t SimNodesType) Equal(o attr.Type) bool {
	other, ok := o.(SimNodesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SimNodesType) String() string {
	return "SimNodesType"
}

func (t SimNodesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	imageAttribute, ok := attributes["image"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`image is missing from object`)

		return nil, diags
	}

	imageVal, ok := imageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`image expected to be basetypes.StringValue, was: %T`, imageAttribute))
	}

	imagePullSecretAttribute, ok := attributes["image_pull_secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`image_pull_secret is missing from object`)

		return nil, diags
	}

	imagePullSecretVal, ok := imagePullSecretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`image_pull_secret expected to be basetypes.StringValue, was: %T`, imagePullSecretAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	templateAttribute, ok := attributes["template"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`template is missing from object`)

		return nil, diags
	}

	templateVal, ok := templateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`template expected to be basetypes.StringValue, was: %T`, templateAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SimNodesValue{
		Image:           imageVal,
		ImagePullSecret: imagePullSecretVal,
		Name:            nameVal,
		Template:        templateVal,
		SimNodesType:    typeVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewSimNodesValueNull() SimNodesValue {
	return SimNodesValue{
		state: attr.ValueStateNull,
	}
}

func NewSimNodesValueUnknown() SimNodesValue {
	return SimNodesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSimNodesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SimNodesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SimNodesValue Attribute Value",
				"While creating a SimNodesValue value, a missing attribute value was detected. "+
					"A SimNodesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SimNodesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SimNodesValue Attribute Type",
				"While creating a SimNodesValue value, an invalid attribute value was detected. "+
					"A SimNodesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SimNodesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SimNodesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SimNodesValue Attribute Value",
				"While creating a SimNodesValue value, an extra attribute value was detected. "+
					"A SimNodesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SimNodesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSimNodesValueUnknown(), diags
	}

	imageAttribute, ok := attributes["image"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`image is missing from object`)

		return NewSimNodesValueUnknown(), diags
	}

	imageVal, ok := imageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`image expected to be basetypes.StringValue, was: %T`, imageAttribute))
	}

	imagePullSecretAttribute, ok := attributes["image_pull_secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`image_pull_secret is missing from object`)

		return NewSimNodesValueUnknown(), diags
	}

	imagePullSecretVal, ok := imagePullSecretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`image_pull_secret expected to be basetypes.StringValue, was: %T`, imagePullSecretAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewSimNodesValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	templateAttribute, ok := attributes["template"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`template is missing from object`)

		return NewSimNodesValueUnknown(), diags
	}

	templateVal, ok := templateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`template expected to be basetypes.StringValue, was: %T`, templateAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewSimNodesValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewSimNodesValueUnknown(), diags
	}

	return SimNodesValue{
		Image:           imageVal,
		ImagePullSecret: imagePullSecretVal,
		Name:            nameVal,
		Template:        templateVal,
		SimNodesType:    typeVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewSimNodesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SimNodesValue {
	object, diags := NewSimNodesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSimNodesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SimNodesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSimNodesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSimNodesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSimNodesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSimNodesValueMust(SimNodesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SimNodesType) ValueType(ctx context.Context) attr.Value {
	return SimNodesValue{}
}

var _ basetypes.ObjectValuable = SimNodesValue{}

type SimNodesValue struct {
	Image           basetypes.StringValue `tfsdk:"image"`
	ImagePullSecret basetypes.StringValue `tfsdk:"image_pull_secret"`
	Name            basetypes.StringValue `tfsdk:"name"`
	Template        basetypes.StringValue `tfsdk:"template"`
	SimNodesType    basetypes.StringValue `tfsdk:"type"`
	state           attr.ValueState
}

func (v SimNodesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["image"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["image_pull_secret"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["template"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Image.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["image"] = val

		val, err = v.ImagePullSecret.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["image_pull_secret"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Template.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["template"] = val

		val, err = v.SimNodesType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SimNodesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SimNodesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SimNodesValue) String() string {
	return "SimNodesValue"
}

func (v SimNodesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"image":             basetypes.StringType{},
		"image_pull_secret": basetypes.StringType{},
		"name":              basetypes.StringType{},
		"template":          basetypes.StringType{},
		"type":              basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"image":             v.Image,
			"image_pull_secret": v.ImagePullSecret,
			"name":              v.Name,
			"template":          v.Template,
			"type":              v.SimNodesType,
		})

	return objVal, diags
}

func (v SimNodesValue) Equal(o attr.Value) bool {
	other, ok := o.(SimNodesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Image.Equal(other.Image) {
		return false
	}

	if !v.ImagePullSecret.Equal(other.ImagePullSecret) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Template.Equal(other.Template) {
		return false
	}

	if !v.SimNodesType.Equal(other.SimNodesType) {
		return false
	}

	return true
}

func (v SimNodesValue) Type(ctx context.Context) attr.Type {
	return SimNodesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SimNodesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"image":             basetypes.StringType{},
		"image_pull_secret": basetypes.StringType{},
		"name":              basetypes.StringType{},
		"template":          basetypes.StringType{},
		"type":              basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = TopologyType{}

type TopologyType struct {
	basetypes.ObjectType
}

func (t TopologyType) Equal(o attr.Type) bool {
	other, ok := o.(TopologyType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TopologyType) String() string {
	return "TopologyType"
}

func (t TopologyType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	interfaceAttribute, ok := attributes["interface"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface is missing from object`)

		return nil, diags
	}

	interfaceVal, ok := interfaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface expected to be basetypes.StringValue, was: %T`, interfaceAttribute))
	}

	nodeAttribute, ok := attributes["node"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node is missing from object`)

		return nil, diags
	}

	nodeVal, ok := nodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node expected to be basetypes.StringValue, was: %T`, nodeAttribute))
	}

	simNodeAttribute, ok := attributes["sim_node"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sim_node is missing from object`)

		return nil, diags
	}

	simNodeVal, ok := simNodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sim_node expected to be basetypes.StringValue, was: %T`, simNodeAttribute))
	}

	simNodeInterfaceAttribute, ok := attributes["sim_node_interface"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sim_node_interface is missing from object`)

		return nil, diags
	}

	simNodeInterfaceVal, ok := simNodeInterfaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sim_node_interface expected to be basetypes.StringValue, was: %T`, simNodeInterfaceAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return TopologyValue{
		Interface:        interfaceVal,
		Node:             nodeVal,
		SimNode:          simNodeVal,
		SimNodeInterface: simNodeInterfaceVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewTopologyValueNull() TopologyValue {
	return TopologyValue{
		state: attr.ValueStateNull,
	}
}

func NewTopologyValueUnknown() TopologyValue {
	return TopologyValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTopologyValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TopologyValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TopologyValue Attribute Value",
				"While creating a TopologyValue value, a missing attribute value was detected. "+
					"A TopologyValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TopologyValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TopologyValue Attribute Type",
				"While creating a TopologyValue value, an invalid attribute value was detected. "+
					"A TopologyValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TopologyValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TopologyValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TopologyValue Attribute Value",
				"While creating a TopologyValue value, an extra attribute value was detected. "+
					"A TopologyValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TopologyValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTopologyValueUnknown(), diags
	}

	interfaceAttribute, ok := attributes["interface"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface is missing from object`)

		return NewTopologyValueUnknown(), diags
	}

	interfaceVal, ok := interfaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface expected to be basetypes.StringValue, was: %T`, interfaceAttribute))
	}

	nodeAttribute, ok := attributes["node"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node is missing from object`)

		return NewTopologyValueUnknown(), diags
	}

	nodeVal, ok := nodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node expected to be basetypes.StringValue, was: %T`, nodeAttribute))
	}

	simNodeAttribute, ok := attributes["sim_node"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sim_node is missing from object`)

		return NewTopologyValueUnknown(), diags
	}

	simNodeVal, ok := simNodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sim_node expected to be basetypes.StringValue, was: %T`, simNodeAttribute))
	}

	simNodeInterfaceAttribute, ok := attributes["sim_node_interface"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sim_node_interface is missing from object`)

		return NewTopologyValueUnknown(), diags
	}

	simNodeInterfaceVal, ok := simNodeInterfaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sim_node_interface expected to be basetypes.StringValue, was: %T`, simNodeInterfaceAttribute))
	}

	if diags.HasError() {
		return NewTopologyValueUnknown(), diags
	}

	return TopologyValue{
		Interface:        interfaceVal,
		Node:             nodeVal,
		SimNode:          simNodeVal,
		SimNodeInterface: simNodeInterfaceVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewTopologyValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TopologyValue {
	object, diags := NewTopologyValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTopologyValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TopologyType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTopologyValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTopologyValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTopologyValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTopologyValueMust(TopologyValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TopologyType) ValueType(ctx context.Context) attr.Value {
	return TopologyValue{}
}

var _ basetypes.ObjectValuable = TopologyValue{}

type TopologyValue struct {
	Interface        basetypes.StringValue `tfsdk:"interface"`
	Node             basetypes.StringValue `tfsdk:"node"`
	SimNode          basetypes.StringValue `tfsdk:"sim_node"`
	SimNodeInterface basetypes.StringValue `tfsdk:"sim_node_interface"`
	state            attr.ValueState
}

func (v TopologyValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["interface"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["node"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["sim_node"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["sim_node_interface"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Interface.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface"] = val

		val, err = v.Node.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["node"] = val

		val, err = v.SimNode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sim_node"] = val

		val, err = v.SimNodeInterface.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sim_node_interface"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TopologyValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TopologyValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TopologyValue) String() string {
	return "TopologyValue"
}

func (v TopologyValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"interface":          basetypes.StringType{},
		"node":               basetypes.StringType{},
		"sim_node":           basetypes.StringType{},
		"sim_node_interface": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"interface":          v.Interface,
			"node":               v.Node,
			"sim_node":           v.SimNode,
			"sim_node_interface": v.SimNodeInterface,
		})

	return objVal, diags
}

func (v TopologyValue) Equal(o attr.Value) bool {
	other, ok := o.(TopologyValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Interface.Equal(other.Interface) {
		return false
	}

	if !v.Node.Equal(other.Node) {
		return false
	}

	if !v.SimNode.Equal(other.SimNode) {
		return false
	}

	if !v.SimNodeInterface.Equal(other.SimNodeInterface) {
		return false
	}

	return true
}

func (v TopologyValue) Type(ctx context.Context) attr.Type {
	return TopologyType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TopologyValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"interface":          basetypes.StringType{},
		"node":               basetypes.StringType{},
		"sim_node":           basetypes.StringType{},
		"sim_node_interface": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = StatusType{}

type StatusType struct {
	basetypes.ObjectType
}

func (t StatusType) Equal(o attr.Type) bool {
	other, ok := o.(StatusType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t StatusType) String() string {
	return "StatusType"
}

func (t StatusType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	messageAttribute, ok := attributes["message"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`message is missing from object`)

		return nil, diags
	}

	messageVal, ok := messageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`message expected to be basetypes.StringValue, was: %T`, messageAttribute))
	}

	processedAttribute, ok := attributes["processed"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`processed is missing from object`)

		return nil, diags
	}

	processedVal, ok := processedAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`processed expected to be basetypes.ObjectValue, was: %T`, processedAttribute))
	}

	resultAttribute, ok := attributes["result"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`result is missing from object`)

		return nil, diags
	}

	resultVal, ok := resultAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`result expected to be basetypes.StringValue, was: %T`, resultAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return StatusValue{
		Message:   messageVal,
		Processed: processedVal,
		Result:    resultVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewStatusValueNull() StatusValue {
	return StatusValue{
		state: attr.ValueStateNull,
	}
}

func NewStatusValueUnknown() StatusValue {
	return StatusValue{
		state: attr.ValueStateUnknown,
	}
}

func NewStatusValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (StatusValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing StatusValue Attribute Value",
				"While creating a StatusValue value, a missing attribute value was detected. "+
					"A StatusValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StatusValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid StatusValue Attribute Type",
				"While creating a StatusValue value, an invalid attribute value was detected. "+
					"A StatusValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StatusValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("StatusValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra StatusValue Attribute Value",
				"While creating a StatusValue value, an extra attribute value was detected. "+
					"A StatusValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra StatusValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewStatusValueUnknown(), diags
	}

	messageAttribute, ok := attributes["message"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`message is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	messageVal, ok := messageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`message expected to be basetypes.StringValue, was: %T`, messageAttribute))
	}

	processedAttribute, ok := attributes["processed"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`processed is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	processedVal, ok := processedAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`processed expected to be basetypes.ObjectValue, was: %T`, processedAttribute))
	}

	resultAttribute, ok := attributes["result"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`result is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	resultVal, ok := resultAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`result expected to be basetypes.StringValue, was: %T`, resultAttribute))
	}

	if diags.HasError() {
		return NewStatusValueUnknown(), diags
	}

	return StatusValue{
		Message:   messageVal,
		Processed: processedVal,
		Result:    resultVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewStatusValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) StatusValue {
	object, diags := NewStatusValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewStatusValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t StatusType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewStatusValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewStatusValueUnknown(), nil
	}

	if in.IsNull() {
		return NewStatusValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewStatusValueMust(StatusValue{}.AttributeTypes(ctx), attributes), nil
}

func (t StatusType) ValueType(ctx context.Context) attr.Value {
	return StatusValue{}
}

var _ basetypes.ObjectValuable = StatusValue{}

type StatusValue struct {
	Message   basetypes.StringValue `tfsdk:"message"`
	Processed basetypes.ObjectValue `tfsdk:"processed"`
	Result    basetypes.StringValue `tfsdk:"result"`
	state     attr.ValueState
}

func (v StatusValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["message"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["processed"] = basetypes.ObjectType{
		AttrTypes: ProcessedValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["result"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Message.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["message"] = val

		val, err = v.Processed.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["processed"] = val

		val, err = v.Result.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["result"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v StatusValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v StatusValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v StatusValue) String() string {
	return "StatusValue"
}

func (v StatusValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var processed basetypes.ObjectValue

	if v.Processed.IsNull() {
		processed = types.ObjectNull(
			ProcessedValue{}.AttributeTypes(ctx),
		)
	}

	if v.Processed.IsUnknown() {
		processed = types.ObjectUnknown(
			ProcessedValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Processed.IsNull() && !v.Processed.IsUnknown() {
		processed = types.ObjectValueMust(
			ProcessedValue{}.AttributeTypes(ctx),
			v.Processed.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"message": basetypes.StringType{},
		"processed": basetypes.ObjectType{
			AttrTypes: ProcessedValue{}.AttributeTypes(ctx),
		},
		"result": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"message":   v.Message,
			"processed": processed,
			"result":    v.Result,
		})

	return objVal, diags
}

func (v StatusValue) Equal(o attr.Value) bool {
	other, ok := o.(StatusValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Message.Equal(other.Message) {
		return false
	}

	if !v.Processed.Equal(other.Processed) {
		return false
	}

	if !v.Result.Equal(other.Result) {
		return false
	}

	return true
}

func (v StatusValue) Type(ctx context.Context) attr.Type {
	return StatusType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v StatusValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"message": basetypes.StringType{},
		"processed": basetypes.ObjectType{
			AttrTypes: ProcessedValue{}.AttributeTypes(ctx),
		},
		"result": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ProcessedType{}

type ProcessedType struct {
	basetypes.ObjectType
}

func (t ProcessedType) Equal(o attr.Type) bool {
	other, ok := o.(ProcessedType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ProcessedType) String() string {
	return "ProcessedType"
}

func (t ProcessedType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	breakouts1Attribute, ok := attributes["breakouts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`breakouts_1 is missing from object`)

		return nil, diags
	}

	breakouts1Val, ok := breakouts1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`breakouts_1 expected to be basetypes.ObjectValue, was: %T`, breakouts1Attribute))
	}

	interfacesAttribute, ok := attributes["interfaces"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interfaces is missing from object`)

		return nil, diags
	}

	interfacesVal, ok := interfacesAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interfaces expected to be basetypes.ObjectValue, was: %T`, interfacesAttribute))
	}

	links1Attribute, ok := attributes["links"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`links_1 is missing from object`)

		return nil, diags
	}

	links1Val, ok := links1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`links_1 expected to be basetypes.ObjectValue, was: %T`, links1Attribute))
	}

	nodes1Attribute, ok := attributes["nodes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`nodes_1 is missing from object`)

		return nil, diags
	}

	nodes1Val, ok := nodes1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`nodes_1 expected to be basetypes.ObjectValue, was: %T`, nodes1Attribute))
	}

	simLinksAttribute, ok := attributes["sim_links"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sim_links is missing from object`)

		return nil, diags
	}

	simLinksVal, ok := simLinksAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sim_links expected to be basetypes.ObjectValue, was: %T`, simLinksAttribute))
	}

	simNodes1Attribute, ok := attributes["sim_nodes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sim_nodes_1 is missing from object`)

		return nil, diags
	}

	simNodes1Val, ok := simNodes1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sim_nodes_1 expected to be basetypes.ObjectValue, was: %T`, simNodes1Attribute))
	}

	totalDurationAttribute, ok := attributes["total_duration"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`total_duration is missing from object`)

		return nil, diags
	}

	totalDurationVal, ok := totalDurationAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`total_duration expected to be basetypes.StringValue, was: %T`, totalDurationAttribute))
	}

	totalResourcesAttribute, ok := attributes["total_resources"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`total_resources is missing from object`)

		return nil, diags
	}

	totalResourcesVal, ok := totalResourcesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`total_resources expected to be basetypes.Int64Value, was: %T`, totalResourcesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ProcessedValue{
		Breakouts1:     breakouts1Val,
		Interfaces:     interfacesVal,
		Links1:         links1Val,
		Nodes1:         nodes1Val,
		SimLinks:       simLinksVal,
		SimNodes1:      simNodes1Val,
		TotalDuration:  totalDurationVal,
		TotalResources: totalResourcesVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewProcessedValueNull() ProcessedValue {
	return ProcessedValue{
		state: attr.ValueStateNull,
	}
}

func NewProcessedValueUnknown() ProcessedValue {
	return ProcessedValue{
		state: attr.ValueStateUnknown,
	}
}

func NewProcessedValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ProcessedValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ProcessedValue Attribute Value",
				"While creating a ProcessedValue value, a missing attribute value was detected. "+
					"A ProcessedValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ProcessedValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ProcessedValue Attribute Type",
				"While creating a ProcessedValue value, an invalid attribute value was detected. "+
					"A ProcessedValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ProcessedValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ProcessedValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ProcessedValue Attribute Value",
				"While creating a ProcessedValue value, an extra attribute value was detected. "+
					"A ProcessedValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ProcessedValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewProcessedValueUnknown(), diags
	}

	breakouts1Attribute, ok := attributes["breakouts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`breakouts_1 is missing from object`)

		return NewProcessedValueUnknown(), diags
	}

	breakouts1Val, ok := breakouts1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`breakouts_1 expected to be basetypes.ObjectValue, was: %T`, breakouts1Attribute))
	}

	interfacesAttribute, ok := attributes["interfaces"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interfaces is missing from object`)

		return NewProcessedValueUnknown(), diags
	}

	interfacesVal, ok := interfacesAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interfaces expected to be basetypes.ObjectValue, was: %T`, interfacesAttribute))
	}

	links1Attribute, ok := attributes["links"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`links_1 is missing from object`)

		return NewProcessedValueUnknown(), diags
	}

	links1Val, ok := links1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`links_1 expected to be basetypes.ObjectValue, was: %T`, links1Attribute))
	}

	nodes1Attribute, ok := attributes["nodes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`nodes_1 is missing from object`)

		return NewProcessedValueUnknown(), diags
	}

	nodes1Val, ok := nodes1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`nodes_1 expected to be basetypes.ObjectValue, was: %T`, nodes1Attribute))
	}

	simLinksAttribute, ok := attributes["sim_links"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sim_links is missing from object`)

		return NewProcessedValueUnknown(), diags
	}

	simLinksVal, ok := simLinksAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sim_links expected to be basetypes.ObjectValue, was: %T`, simLinksAttribute))
	}

	simNodes1Attribute, ok := attributes["sim_nodes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sim_nodes_1 is missing from object`)

		return NewProcessedValueUnknown(), diags
	}

	simNodes1Val, ok := simNodes1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sim_nodes_1 expected to be basetypes.ObjectValue, was: %T`, simNodes1Attribute))
	}

	totalDurationAttribute, ok := attributes["total_duration"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`total_duration is missing from object`)

		return NewProcessedValueUnknown(), diags
	}

	totalDurationVal, ok := totalDurationAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`total_duration expected to be basetypes.StringValue, was: %T`, totalDurationAttribute))
	}

	totalResourcesAttribute, ok := attributes["total_resources"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`total_resources is missing from object`)

		return NewProcessedValueUnknown(), diags
	}

	totalResourcesVal, ok := totalResourcesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`total_resources expected to be basetypes.Int64Value, was: %T`, totalResourcesAttribute))
	}

	if diags.HasError() {
		return NewProcessedValueUnknown(), diags
	}

	return ProcessedValue{
		Breakouts1:     breakouts1Val,
		Interfaces:     interfacesVal,
		Links1:         links1Val,
		Nodes1:         nodes1Val,
		SimLinks:       simLinksVal,
		SimNodes1:      simNodes1Val,
		TotalDuration:  totalDurationVal,
		TotalResources: totalResourcesVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewProcessedValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ProcessedValue {
	object, diags := NewProcessedValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewProcessedValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ProcessedType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewProcessedValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewProcessedValueUnknown(), nil
	}

	if in.IsNull() {
		return NewProcessedValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewProcessedValueMust(ProcessedValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ProcessedType) ValueType(ctx context.Context) attr.Value {
	return ProcessedValue{}
}

var _ basetypes.ObjectValuable = ProcessedValue{}

type ProcessedValue struct {
	Breakouts1     basetypes.ObjectValue `tfsdk:"breakouts"`
	Interfaces     basetypes.ObjectValue `tfsdk:"interfaces"`
	Links1         basetypes.ObjectValue `tfsdk:"links"`
	Nodes1         basetypes.ObjectValue `tfsdk:"nodes"`
	SimLinks       basetypes.ObjectValue `tfsdk:"sim_links"`
	SimNodes1      basetypes.ObjectValue `tfsdk:"sim_nodes"`
	TotalDuration  basetypes.StringValue `tfsdk:"total_duration"`
	TotalResources basetypes.Int64Value  `tfsdk:"total_resources"`
	state          attr.ValueState
}

func (v ProcessedValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 8)

	var val tftypes.Value
	var err error

	attrTypes["breakouts"] = basetypes.ObjectType{
		AttrTypes: Breakouts1Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["interfaces"] = basetypes.ObjectType{
		AttrTypes: InterfacesValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["links"] = basetypes.ObjectType{
		AttrTypes: Links1Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["nodes"] = basetypes.ObjectType{
		AttrTypes: Nodes1Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["sim_links"] = basetypes.ObjectType{
		AttrTypes: SimLinksValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["sim_nodes"] = basetypes.ObjectType{
		AttrTypes: SimNodes1Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["total_duration"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["total_resources"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 8)

		val, err = v.Breakouts1.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["breakouts"] = val

		val, err = v.Interfaces.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interfaces"] = val

		val, err = v.Links1.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["links"] = val

		val, err = v.Nodes1.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["nodes"] = val

		val, err = v.SimLinks.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sim_links"] = val

		val, err = v.SimNodes1.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sim_nodes"] = val

		val, err = v.TotalDuration.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["total_duration"] = val

		val, err = v.TotalResources.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["total_resources"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ProcessedValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ProcessedValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ProcessedValue) String() string {
	return "ProcessedValue"
}

func (v ProcessedValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var breakouts1 basetypes.ObjectValue

	if v.Breakouts1.IsNull() {
		breakouts1 = types.ObjectNull(
			Breakouts1Value{}.AttributeTypes(ctx),
		)
	}

	if v.Breakouts1.IsUnknown() {
		breakouts1 = types.ObjectUnknown(
			Breakouts1Value{}.AttributeTypes(ctx),
		)
	}

	if !v.Breakouts1.IsNull() && !v.Breakouts1.IsUnknown() {
		breakouts1 = types.ObjectValueMust(
			Breakouts1Value{}.AttributeTypes(ctx),
			v.Breakouts1.Attributes(),
		)
	}

	var interfaces basetypes.ObjectValue

	if v.Interfaces.IsNull() {
		interfaces = types.ObjectNull(
			InterfacesValue{}.AttributeTypes(ctx),
		)
	}

	if v.Interfaces.IsUnknown() {
		interfaces = types.ObjectUnknown(
			InterfacesValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Interfaces.IsNull() && !v.Interfaces.IsUnknown() {
		interfaces = types.ObjectValueMust(
			InterfacesValue{}.AttributeTypes(ctx),
			v.Interfaces.Attributes(),
		)
	}

	var links1 basetypes.ObjectValue

	if v.Links1.IsNull() {
		links1 = types.ObjectNull(
			Links1Value{}.AttributeTypes(ctx),
		)
	}

	if v.Links1.IsUnknown() {
		links1 = types.ObjectUnknown(
			Links1Value{}.AttributeTypes(ctx),
		)
	}

	if !v.Links1.IsNull() && !v.Links1.IsUnknown() {
		links1 = types.ObjectValueMust(
			Links1Value{}.AttributeTypes(ctx),
			v.Links1.Attributes(),
		)
	}

	var nodes1 basetypes.ObjectValue

	if v.Nodes1.IsNull() {
		nodes1 = types.ObjectNull(
			Nodes1Value{}.AttributeTypes(ctx),
		)
	}

	if v.Nodes1.IsUnknown() {
		nodes1 = types.ObjectUnknown(
			Nodes1Value{}.AttributeTypes(ctx),
		)
	}

	if !v.Nodes1.IsNull() && !v.Nodes1.IsUnknown() {
		nodes1 = types.ObjectValueMust(
			Nodes1Value{}.AttributeTypes(ctx),
			v.Nodes1.Attributes(),
		)
	}

	var simLinks basetypes.ObjectValue

	if v.SimLinks.IsNull() {
		simLinks = types.ObjectNull(
			SimLinksValue{}.AttributeTypes(ctx),
		)
	}

	if v.SimLinks.IsUnknown() {
		simLinks = types.ObjectUnknown(
			SimLinksValue{}.AttributeTypes(ctx),
		)
	}

	if !v.SimLinks.IsNull() && !v.SimLinks.IsUnknown() {
		simLinks = types.ObjectValueMust(
			SimLinksValue{}.AttributeTypes(ctx),
			v.SimLinks.Attributes(),
		)
	}

	var simNodes1 basetypes.ObjectValue

	if v.SimNodes1.IsNull() {
		simNodes1 = types.ObjectNull(
			SimNodes1Value{}.AttributeTypes(ctx),
		)
	}

	if v.SimNodes1.IsUnknown() {
		simNodes1 = types.ObjectUnknown(
			SimNodes1Value{}.AttributeTypes(ctx),
		)
	}

	if !v.SimNodes1.IsNull() && !v.SimNodes1.IsUnknown() {
		simNodes1 = types.ObjectValueMust(
			SimNodes1Value{}.AttributeTypes(ctx),
			v.SimNodes1.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"breakouts": basetypes.ObjectType{
			AttrTypes: Breakouts1Value{}.AttributeTypes(ctx),
		},
		"interfaces": basetypes.ObjectType{
			AttrTypes: InterfacesValue{}.AttributeTypes(ctx),
		},
		"links": basetypes.ObjectType{
			AttrTypes: Links1Value{}.AttributeTypes(ctx),
		},
		"nodes": basetypes.ObjectType{
			AttrTypes: Nodes1Value{}.AttributeTypes(ctx),
		},
		"sim_links": basetypes.ObjectType{
			AttrTypes: SimLinksValue{}.AttributeTypes(ctx),
		},
		"sim_nodes": basetypes.ObjectType{
			AttrTypes: SimNodes1Value{}.AttributeTypes(ctx),
		},
		"total_duration":  basetypes.StringType{},
		"total_resources": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"breakouts":       breakouts1,
			"interfaces":      interfaces,
			"links":           links1,
			"nodes":           nodes1,
			"sim_links":       simLinks,
			"sim_nodes":       simNodes1,
			"total_duration":  v.TotalDuration,
			"total_resources": v.TotalResources,
		})

	return objVal, diags
}

func (v ProcessedValue) Equal(o attr.Value) bool {
	other, ok := o.(ProcessedValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Breakouts1.Equal(other.Breakouts1) {
		return false
	}

	if !v.Interfaces.Equal(other.Interfaces) {
		return false
	}

	if !v.Links1.Equal(other.Links1) {
		return false
	}

	if !v.Nodes1.Equal(other.Nodes1) {
		return false
	}

	if !v.SimLinks.Equal(other.SimLinks) {
		return false
	}

	if !v.SimNodes1.Equal(other.SimNodes1) {
		return false
	}

	if !v.TotalDuration.Equal(other.TotalDuration) {
		return false
	}

	if !v.TotalResources.Equal(other.TotalResources) {
		return false
	}

	return true
}

func (v ProcessedValue) Type(ctx context.Context) attr.Type {
	return ProcessedType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ProcessedValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"breakouts": basetypes.ObjectType{
			AttrTypes: Breakouts1Value{}.AttributeTypes(ctx),
		},
		"interfaces": basetypes.ObjectType{
			AttrTypes: InterfacesValue{}.AttributeTypes(ctx),
		},
		"links": basetypes.ObjectType{
			AttrTypes: Links1Value{}.AttributeTypes(ctx),
		},
		"nodes": basetypes.ObjectType{
			AttrTypes: Nodes1Value{}.AttributeTypes(ctx),
		},
		"sim_links": basetypes.ObjectType{
			AttrTypes: SimLinksValue{}.AttributeTypes(ctx),
		},
		"sim_nodes": basetypes.ObjectType{
			AttrTypes: SimNodes1Value{}.AttributeTypes(ctx),
		},
		"total_duration":  basetypes.StringType{},
		"total_resources": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = Breakouts1Type{}

type Breakouts1Type struct {
	basetypes.ObjectType
}

func (t Breakouts1Type) Equal(o attr.Type) bool {
	other, ok := o.(Breakouts1Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Breakouts1Type) String() string {
	return "Breakouts1Type"
}

func (t Breakouts1Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	createdAttribute, ok := attributes["created"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created is missing from object`)

		return nil, diags
	}

	createdVal, ok := createdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created expected to be basetypes.Int64Value, was: %T`, createdAttribute))
	}

	deletedAttribute, ok := attributes["deleted"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`deleted is missing from object`)

		return nil, diags
	}

	deletedVal, ok := deletedAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`deleted expected to be basetypes.Int64Value, was: %T`, deletedAttribute))
	}

	updatedAttribute, ok := attributes["updated"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`updated is missing from object`)

		return nil, diags
	}

	updatedVal, ok := updatedAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`updated expected to be basetypes.Int64Value, was: %T`, updatedAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Breakouts1Value{
		Created: createdVal,
		Deleted: deletedVal,
		Updated: updatedVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewBreakouts1ValueNull() Breakouts1Value {
	return Breakouts1Value{
		state: attr.ValueStateNull,
	}
}

func NewBreakouts1ValueUnknown() Breakouts1Value {
	return Breakouts1Value{
		state: attr.ValueStateUnknown,
	}
}

func NewBreakouts1Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Breakouts1Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Breakouts1Value Attribute Value",
				"While creating a Breakouts1Value value, a missing attribute value was detected. "+
					"A Breakouts1Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Breakouts1Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Breakouts1Value Attribute Type",
				"While creating a Breakouts1Value value, an invalid attribute value was detected. "+
					"A Breakouts1Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Breakouts1Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Breakouts1Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Breakouts1Value Attribute Value",
				"While creating a Breakouts1Value value, an extra attribute value was detected. "+
					"A Breakouts1Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Breakouts1Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewBreakouts1ValueUnknown(), diags
	}

	createdAttribute, ok := attributes["created"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created is missing from object`)

		return NewBreakouts1ValueUnknown(), diags
	}

	createdVal, ok := createdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created expected to be basetypes.Int64Value, was: %T`, createdAttribute))
	}

	deletedAttribute, ok := attributes["deleted"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`deleted is missing from object`)

		return NewBreakouts1ValueUnknown(), diags
	}

	deletedVal, ok := deletedAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`deleted expected to be basetypes.Int64Value, was: %T`, deletedAttribute))
	}

	updatedAttribute, ok := attributes["updated"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`updated is missing from object`)

		return NewBreakouts1ValueUnknown(), diags
	}

	updatedVal, ok := updatedAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`updated expected to be basetypes.Int64Value, was: %T`, updatedAttribute))
	}

	if diags.HasError() {
		return NewBreakouts1ValueUnknown(), diags
	}

	return Breakouts1Value{
		Created: createdVal,
		Deleted: deletedVal,
		Updated: updatedVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewBreakouts1ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Breakouts1Value {
	object, diags := NewBreakouts1Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewBreakouts1ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Breakouts1Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewBreakouts1ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewBreakouts1ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewBreakouts1ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewBreakouts1ValueMust(Breakouts1Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Breakouts1Type) ValueType(ctx context.Context) attr.Value {
	return Breakouts1Value{}
}

var _ basetypes.ObjectValuable = Breakouts1Value{}

type Breakouts1Value struct {
	Created basetypes.Int64Value `tfsdk:"created"`
	Deleted basetypes.Int64Value `tfsdk:"deleted"`
	Updated basetypes.Int64Value `tfsdk:"updated"`
	state   attr.ValueState
}

func (v Breakouts1Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["created"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["deleted"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["updated"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Created.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["created"] = val

		val, err = v.Deleted.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["deleted"] = val

		val, err = v.Updated.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["updated"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Breakouts1Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Breakouts1Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Breakouts1Value) String() string {
	return "Breakouts1Value"
}

func (v Breakouts1Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"created": basetypes.Int64Type{},
		"deleted": basetypes.Int64Type{},
		"updated": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"created": v.Created,
			"deleted": v.Deleted,
			"updated": v.Updated,
		})

	return objVal, diags
}

func (v Breakouts1Value) Equal(o attr.Value) bool {
	other, ok := o.(Breakouts1Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Created.Equal(other.Created) {
		return false
	}

	if !v.Deleted.Equal(other.Deleted) {
		return false
	}

	if !v.Updated.Equal(other.Updated) {
		return false
	}

	return true
}

func (v Breakouts1Value) Type(ctx context.Context) attr.Type {
	return Breakouts1Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Breakouts1Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"created": basetypes.Int64Type{},
		"deleted": basetypes.Int64Type{},
		"updated": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = InterfacesType{}

type InterfacesType struct {
	basetypes.ObjectType
}

func (t InterfacesType) Equal(o attr.Type) bool {
	other, ok := o.(InterfacesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t InterfacesType) String() string {
	return "InterfacesType"
}

func (t InterfacesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	createdAttribute, ok := attributes["created"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created is missing from object`)

		return nil, diags
	}

	createdVal, ok := createdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created expected to be basetypes.Int64Value, was: %T`, createdAttribute))
	}

	deletedAttribute, ok := attributes["deleted"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`deleted is missing from object`)

		return nil, diags
	}

	deletedVal, ok := deletedAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`deleted expected to be basetypes.Int64Value, was: %T`, deletedAttribute))
	}

	updatedAttribute, ok := attributes["updated"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`updated is missing from object`)

		return nil, diags
	}

	updatedVal, ok := updatedAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`updated expected to be basetypes.Int64Value, was: %T`, updatedAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return InterfacesValue{
		Created: createdVal,
		Deleted: deletedVal,
		Updated: updatedVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewInterfacesValueNull() InterfacesValue {
	return InterfacesValue{
		state: attr.ValueStateNull,
	}
}

func NewInterfacesValueUnknown() InterfacesValue {
	return InterfacesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewInterfacesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (InterfacesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing InterfacesValue Attribute Value",
				"While creating a InterfacesValue value, a missing attribute value was detected. "+
					"A InterfacesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InterfacesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid InterfacesValue Attribute Type",
				"While creating a InterfacesValue value, an invalid attribute value was detected. "+
					"A InterfacesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InterfacesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("InterfacesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra InterfacesValue Attribute Value",
				"While creating a InterfacesValue value, an extra attribute value was detected. "+
					"A InterfacesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra InterfacesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewInterfacesValueUnknown(), diags
	}

	createdAttribute, ok := attributes["created"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created is missing from object`)

		return NewInterfacesValueUnknown(), diags
	}

	createdVal, ok := createdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created expected to be basetypes.Int64Value, was: %T`, createdAttribute))
	}

	deletedAttribute, ok := attributes["deleted"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`deleted is missing from object`)

		return NewInterfacesValueUnknown(), diags
	}

	deletedVal, ok := deletedAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`deleted expected to be basetypes.Int64Value, was: %T`, deletedAttribute))
	}

	updatedAttribute, ok := attributes["updated"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`updated is missing from object`)

		return NewInterfacesValueUnknown(), diags
	}

	updatedVal, ok := updatedAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`updated expected to be basetypes.Int64Value, was: %T`, updatedAttribute))
	}

	if diags.HasError() {
		return NewInterfacesValueUnknown(), diags
	}

	return InterfacesValue{
		Created: createdVal,
		Deleted: deletedVal,
		Updated: updatedVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewInterfacesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) InterfacesValue {
	object, diags := NewInterfacesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewInterfacesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t InterfacesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewInterfacesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewInterfacesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewInterfacesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewInterfacesValueMust(InterfacesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t InterfacesType) ValueType(ctx context.Context) attr.Value {
	return InterfacesValue{}
}

var _ basetypes.ObjectValuable = InterfacesValue{}

type InterfacesValue struct {
	Created basetypes.Int64Value `tfsdk:"created"`
	Deleted basetypes.Int64Value `tfsdk:"deleted"`
	Updated basetypes.Int64Value `tfsdk:"updated"`
	state   attr.ValueState
}

func (v InterfacesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["created"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["deleted"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["updated"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Created.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["created"] = val

		val, err = v.Deleted.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["deleted"] = val

		val, err = v.Updated.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["updated"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v InterfacesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v InterfacesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v InterfacesValue) String() string {
	return "InterfacesValue"
}

func (v InterfacesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"created": basetypes.Int64Type{},
		"deleted": basetypes.Int64Type{},
		"updated": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"created": v.Created,
			"deleted": v.Deleted,
			"updated": v.Updated,
		})

	return objVal, diags
}

func (v InterfacesValue) Equal(o attr.Value) bool {
	other, ok := o.(InterfacesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Created.Equal(other.Created) {
		return false
	}

	if !v.Deleted.Equal(other.Deleted) {
		return false
	}

	if !v.Updated.Equal(other.Updated) {
		return false
	}

	return true
}

func (v InterfacesValue) Type(ctx context.Context) attr.Type {
	return InterfacesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v InterfacesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"created": basetypes.Int64Type{},
		"deleted": basetypes.Int64Type{},
		"updated": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = Links1Type{}

type Links1Type struct {
	basetypes.ObjectType
}

func (t Links1Type) Equal(o attr.Type) bool {
	other, ok := o.(Links1Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Links1Type) String() string {
	return "Links1Type"
}

func (t Links1Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	createdAttribute, ok := attributes["created"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created is missing from object`)

		return nil, diags
	}

	createdVal, ok := createdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created expected to be basetypes.Int64Value, was: %T`, createdAttribute))
	}

	deletedAttribute, ok := attributes["deleted"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`deleted is missing from object`)

		return nil, diags
	}

	deletedVal, ok := deletedAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`deleted expected to be basetypes.Int64Value, was: %T`, deletedAttribute))
	}

	updatedAttribute, ok := attributes["updated"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`updated is missing from object`)

		return nil, diags
	}

	updatedVal, ok := updatedAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`updated expected to be basetypes.Int64Value, was: %T`, updatedAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Links1Value{
		Created: createdVal,
		Deleted: deletedVal,
		Updated: updatedVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewLinks1ValueNull() Links1Value {
	return Links1Value{
		state: attr.ValueStateNull,
	}
}

func NewLinks1ValueUnknown() Links1Value {
	return Links1Value{
		state: attr.ValueStateUnknown,
	}
}

func NewLinks1Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Links1Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Links1Value Attribute Value",
				"While creating a Links1Value value, a missing attribute value was detected. "+
					"A Links1Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Links1Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Links1Value Attribute Type",
				"While creating a Links1Value value, an invalid attribute value was detected. "+
					"A Links1Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Links1Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Links1Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Links1Value Attribute Value",
				"While creating a Links1Value value, an extra attribute value was detected. "+
					"A Links1Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Links1Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewLinks1ValueUnknown(), diags
	}

	createdAttribute, ok := attributes["created"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created is missing from object`)

		return NewLinks1ValueUnknown(), diags
	}

	createdVal, ok := createdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created expected to be basetypes.Int64Value, was: %T`, createdAttribute))
	}

	deletedAttribute, ok := attributes["deleted"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`deleted is missing from object`)

		return NewLinks1ValueUnknown(), diags
	}

	deletedVal, ok := deletedAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`deleted expected to be basetypes.Int64Value, was: %T`, deletedAttribute))
	}

	updatedAttribute, ok := attributes["updated"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`updated is missing from object`)

		return NewLinks1ValueUnknown(), diags
	}

	updatedVal, ok := updatedAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`updated expected to be basetypes.Int64Value, was: %T`, updatedAttribute))
	}

	if diags.HasError() {
		return NewLinks1ValueUnknown(), diags
	}

	return Links1Value{
		Created: createdVal,
		Deleted: deletedVal,
		Updated: updatedVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewLinks1ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Links1Value {
	object, diags := NewLinks1Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewLinks1ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Links1Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewLinks1ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewLinks1ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewLinks1ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewLinks1ValueMust(Links1Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Links1Type) ValueType(ctx context.Context) attr.Value {
	return Links1Value{}
}

var _ basetypes.ObjectValuable = Links1Value{}

type Links1Value struct {
	Created basetypes.Int64Value `tfsdk:"created"`
	Deleted basetypes.Int64Value `tfsdk:"deleted"`
	Updated basetypes.Int64Value `tfsdk:"updated"`
	state   attr.ValueState
}

func (v Links1Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["created"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["deleted"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["updated"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Created.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["created"] = val

		val, err = v.Deleted.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["deleted"] = val

		val, err = v.Updated.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["updated"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Links1Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Links1Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Links1Value) String() string {
	return "Links1Value"
}

func (v Links1Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"created": basetypes.Int64Type{},
		"deleted": basetypes.Int64Type{},
		"updated": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"created": v.Created,
			"deleted": v.Deleted,
			"updated": v.Updated,
		})

	return objVal, diags
}

func (v Links1Value) Equal(o attr.Value) bool {
	other, ok := o.(Links1Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Created.Equal(other.Created) {
		return false
	}

	if !v.Deleted.Equal(other.Deleted) {
		return false
	}

	if !v.Updated.Equal(other.Updated) {
		return false
	}

	return true
}

func (v Links1Value) Type(ctx context.Context) attr.Type {
	return Links1Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Links1Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"created": basetypes.Int64Type{},
		"deleted": basetypes.Int64Type{},
		"updated": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = Nodes1Type{}

type Nodes1Type struct {
	basetypes.ObjectType
}

func (t Nodes1Type) Equal(o attr.Type) bool {
	other, ok := o.(Nodes1Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Nodes1Type) String() string {
	return "Nodes1Type"
}

func (t Nodes1Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	createdAttribute, ok := attributes["created"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created is missing from object`)

		return nil, diags
	}

	createdVal, ok := createdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created expected to be basetypes.Int64Value, was: %T`, createdAttribute))
	}

	deletedAttribute, ok := attributes["deleted"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`deleted is missing from object`)

		return nil, diags
	}

	deletedVal, ok := deletedAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`deleted expected to be basetypes.Int64Value, was: %T`, deletedAttribute))
	}

	updatedAttribute, ok := attributes["updated"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`updated is missing from object`)

		return nil, diags
	}

	updatedVal, ok := updatedAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`updated expected to be basetypes.Int64Value, was: %T`, updatedAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Nodes1Value{
		Created: createdVal,
		Deleted: deletedVal,
		Updated: updatedVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewNodes1ValueNull() Nodes1Value {
	return Nodes1Value{
		state: attr.ValueStateNull,
	}
}

func NewNodes1ValueUnknown() Nodes1Value {
	return Nodes1Value{
		state: attr.ValueStateUnknown,
	}
}

func NewNodes1Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Nodes1Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Nodes1Value Attribute Value",
				"While creating a Nodes1Value value, a missing attribute value was detected. "+
					"A Nodes1Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Nodes1Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Nodes1Value Attribute Type",
				"While creating a Nodes1Value value, an invalid attribute value was detected. "+
					"A Nodes1Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Nodes1Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Nodes1Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Nodes1Value Attribute Value",
				"While creating a Nodes1Value value, an extra attribute value was detected. "+
					"A Nodes1Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Nodes1Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewNodes1ValueUnknown(), diags
	}

	createdAttribute, ok := attributes["created"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created is missing from object`)

		return NewNodes1ValueUnknown(), diags
	}

	createdVal, ok := createdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created expected to be basetypes.Int64Value, was: %T`, createdAttribute))
	}

	deletedAttribute, ok := attributes["deleted"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`deleted is missing from object`)

		return NewNodes1ValueUnknown(), diags
	}

	deletedVal, ok := deletedAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`deleted expected to be basetypes.Int64Value, was: %T`, deletedAttribute))
	}

	updatedAttribute, ok := attributes["updated"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`updated is missing from object`)

		return NewNodes1ValueUnknown(), diags
	}

	updatedVal, ok := updatedAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`updated expected to be basetypes.Int64Value, was: %T`, updatedAttribute))
	}

	if diags.HasError() {
		return NewNodes1ValueUnknown(), diags
	}

	return Nodes1Value{
		Created: createdVal,
		Deleted: deletedVal,
		Updated: updatedVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewNodes1ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Nodes1Value {
	object, diags := NewNodes1Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewNodes1ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Nodes1Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewNodes1ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewNodes1ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewNodes1ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewNodes1ValueMust(Nodes1Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Nodes1Type) ValueType(ctx context.Context) attr.Value {
	return Nodes1Value{}
}

var _ basetypes.ObjectValuable = Nodes1Value{}

type Nodes1Value struct {
	Created basetypes.Int64Value `tfsdk:"created"`
	Deleted basetypes.Int64Value `tfsdk:"deleted"`
	Updated basetypes.Int64Value `tfsdk:"updated"`
	state   attr.ValueState
}

func (v Nodes1Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["created"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["deleted"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["updated"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Created.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["created"] = val

		val, err = v.Deleted.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["deleted"] = val

		val, err = v.Updated.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["updated"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Nodes1Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Nodes1Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Nodes1Value) String() string {
	return "Nodes1Value"
}

func (v Nodes1Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"created": basetypes.Int64Type{},
		"deleted": basetypes.Int64Type{},
		"updated": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"created": v.Created,
			"deleted": v.Deleted,
			"updated": v.Updated,
		})

	return objVal, diags
}

func (v Nodes1Value) Equal(o attr.Value) bool {
	other, ok := o.(Nodes1Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Created.Equal(other.Created) {
		return false
	}

	if !v.Deleted.Equal(other.Deleted) {
		return false
	}

	if !v.Updated.Equal(other.Updated) {
		return false
	}

	return true
}

func (v Nodes1Value) Type(ctx context.Context) attr.Type {
	return Nodes1Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Nodes1Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"created": basetypes.Int64Type{},
		"deleted": basetypes.Int64Type{},
		"updated": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = SimLinksType{}

type SimLinksType struct {
	basetypes.ObjectType
}

func (t SimLinksType) Equal(o attr.Type) bool {
	other, ok := o.(SimLinksType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SimLinksType) String() string {
	return "SimLinksType"
}

func (t SimLinksType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	createdAttribute, ok := attributes["created"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created is missing from object`)

		return nil, diags
	}

	createdVal, ok := createdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created expected to be basetypes.Int64Value, was: %T`, createdAttribute))
	}

	deletedAttribute, ok := attributes["deleted"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`deleted is missing from object`)

		return nil, diags
	}

	deletedVal, ok := deletedAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`deleted expected to be basetypes.Int64Value, was: %T`, deletedAttribute))
	}

	updatedAttribute, ok := attributes["updated"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`updated is missing from object`)

		return nil, diags
	}

	updatedVal, ok := updatedAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`updated expected to be basetypes.Int64Value, was: %T`, updatedAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SimLinksValue{
		Created: createdVal,
		Deleted: deletedVal,
		Updated: updatedVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewSimLinksValueNull() SimLinksValue {
	return SimLinksValue{
		state: attr.ValueStateNull,
	}
}

func NewSimLinksValueUnknown() SimLinksValue {
	return SimLinksValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSimLinksValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SimLinksValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SimLinksValue Attribute Value",
				"While creating a SimLinksValue value, a missing attribute value was detected. "+
					"A SimLinksValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SimLinksValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SimLinksValue Attribute Type",
				"While creating a SimLinksValue value, an invalid attribute value was detected. "+
					"A SimLinksValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SimLinksValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SimLinksValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SimLinksValue Attribute Value",
				"While creating a SimLinksValue value, an extra attribute value was detected. "+
					"A SimLinksValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SimLinksValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSimLinksValueUnknown(), diags
	}

	createdAttribute, ok := attributes["created"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created is missing from object`)

		return NewSimLinksValueUnknown(), diags
	}

	createdVal, ok := createdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created expected to be basetypes.Int64Value, was: %T`, createdAttribute))
	}

	deletedAttribute, ok := attributes["deleted"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`deleted is missing from object`)

		return NewSimLinksValueUnknown(), diags
	}

	deletedVal, ok := deletedAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`deleted expected to be basetypes.Int64Value, was: %T`, deletedAttribute))
	}

	updatedAttribute, ok := attributes["updated"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`updated is missing from object`)

		return NewSimLinksValueUnknown(), diags
	}

	updatedVal, ok := updatedAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`updated expected to be basetypes.Int64Value, was: %T`, updatedAttribute))
	}

	if diags.HasError() {
		return NewSimLinksValueUnknown(), diags
	}

	return SimLinksValue{
		Created: createdVal,
		Deleted: deletedVal,
		Updated: updatedVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewSimLinksValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SimLinksValue {
	object, diags := NewSimLinksValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSimLinksValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SimLinksType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSimLinksValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSimLinksValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSimLinksValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSimLinksValueMust(SimLinksValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SimLinksType) ValueType(ctx context.Context) attr.Value {
	return SimLinksValue{}
}

var _ basetypes.ObjectValuable = SimLinksValue{}

type SimLinksValue struct {
	Created basetypes.Int64Value `tfsdk:"created"`
	Deleted basetypes.Int64Value `tfsdk:"deleted"`
	Updated basetypes.Int64Value `tfsdk:"updated"`
	state   attr.ValueState
}

func (v SimLinksValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["created"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["deleted"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["updated"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Created.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["created"] = val

		val, err = v.Deleted.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["deleted"] = val

		val, err = v.Updated.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["updated"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SimLinksValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SimLinksValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SimLinksValue) String() string {
	return "SimLinksValue"
}

func (v SimLinksValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"created": basetypes.Int64Type{},
		"deleted": basetypes.Int64Type{},
		"updated": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"created": v.Created,
			"deleted": v.Deleted,
			"updated": v.Updated,
		})

	return objVal, diags
}

func (v SimLinksValue) Equal(o attr.Value) bool {
	other, ok := o.(SimLinksValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Created.Equal(other.Created) {
		return false
	}

	if !v.Deleted.Equal(other.Deleted) {
		return false
	}

	if !v.Updated.Equal(other.Updated) {
		return false
	}

	return true
}

func (v SimLinksValue) Type(ctx context.Context) attr.Type {
	return SimLinksType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SimLinksValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"created": basetypes.Int64Type{},
		"deleted": basetypes.Int64Type{},
		"updated": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = SimNodes1Type{}

type SimNodes1Type struct {
	basetypes.ObjectType
}

func (t SimNodes1Type) Equal(o attr.Type) bool {
	other, ok := o.(SimNodes1Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SimNodes1Type) String() string {
	return "SimNodes1Type"
}

func (t SimNodes1Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	createdAttribute, ok := attributes["created"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created is missing from object`)

		return nil, diags
	}

	createdVal, ok := createdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created expected to be basetypes.Int64Value, was: %T`, createdAttribute))
	}

	deletedAttribute, ok := attributes["deleted"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`deleted is missing from object`)

		return nil, diags
	}

	deletedVal, ok := deletedAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`deleted expected to be basetypes.Int64Value, was: %T`, deletedAttribute))
	}

	updatedAttribute, ok := attributes["updated"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`updated is missing from object`)

		return nil, diags
	}

	updatedVal, ok := updatedAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`updated expected to be basetypes.Int64Value, was: %T`, updatedAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SimNodes1Value{
		Created: createdVal,
		Deleted: deletedVal,
		Updated: updatedVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewSimNodes1ValueNull() SimNodes1Value {
	return SimNodes1Value{
		state: attr.ValueStateNull,
	}
}

func NewSimNodes1ValueUnknown() SimNodes1Value {
	return SimNodes1Value{
		state: attr.ValueStateUnknown,
	}
}

func NewSimNodes1Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SimNodes1Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SimNodes1Value Attribute Value",
				"While creating a SimNodes1Value value, a missing attribute value was detected. "+
					"A SimNodes1Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SimNodes1Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SimNodes1Value Attribute Type",
				"While creating a SimNodes1Value value, an invalid attribute value was detected. "+
					"A SimNodes1Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SimNodes1Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SimNodes1Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SimNodes1Value Attribute Value",
				"While creating a SimNodes1Value value, an extra attribute value was detected. "+
					"A SimNodes1Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SimNodes1Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSimNodes1ValueUnknown(), diags
	}

	createdAttribute, ok := attributes["created"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created is missing from object`)

		return NewSimNodes1ValueUnknown(), diags
	}

	createdVal, ok := createdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created expected to be basetypes.Int64Value, was: %T`, createdAttribute))
	}

	deletedAttribute, ok := attributes["deleted"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`deleted is missing from object`)

		return NewSimNodes1ValueUnknown(), diags
	}

	deletedVal, ok := deletedAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`deleted expected to be basetypes.Int64Value, was: %T`, deletedAttribute))
	}

	updatedAttribute, ok := attributes["updated"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`updated is missing from object`)

		return NewSimNodes1ValueUnknown(), diags
	}

	updatedVal, ok := updatedAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`updated expected to be basetypes.Int64Value, was: %T`, updatedAttribute))
	}

	if diags.HasError() {
		return NewSimNodes1ValueUnknown(), diags
	}

	return SimNodes1Value{
		Created: createdVal,
		Deleted: deletedVal,
		Updated: updatedVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewSimNodes1ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SimNodes1Value {
	object, diags := NewSimNodes1Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSimNodes1ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SimNodes1Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSimNodes1ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSimNodes1ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSimNodes1ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSimNodes1ValueMust(SimNodes1Value{}.AttributeTypes(ctx), attributes), nil
}

func (t SimNodes1Type) ValueType(ctx context.Context) attr.Value {
	return SimNodes1Value{}
}

var _ basetypes.ObjectValuable = SimNodes1Value{}

type SimNodes1Value struct {
	Created basetypes.Int64Value `tfsdk:"created"`
	Deleted basetypes.Int64Value `tfsdk:"deleted"`
	Updated basetypes.Int64Value `tfsdk:"updated"`
	state   attr.ValueState
}

func (v SimNodes1Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["created"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["deleted"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["updated"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Created.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["created"] = val

		val, err = v.Deleted.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["deleted"] = val

		val, err = v.Updated.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["updated"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SimNodes1Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SimNodes1Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SimNodes1Value) String() string {
	return "SimNodes1Value"
}

func (v SimNodes1Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"created": basetypes.Int64Type{},
		"deleted": basetypes.Int64Type{},
		"updated": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"created": v.Created,
			"deleted": v.Deleted,
			"updated": v.Updated,
		})

	return objVal, diags
}

func (v SimNodes1Value) Equal(o attr.Value) bool {
	other, ok := o.(SimNodes1Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Created.Equal(other.Created) {
		return false
	}

	if !v.Deleted.Equal(other.Deleted) {
		return false
	}

	if !v.Updated.Equal(other.Updated) {
		return false
	}

	return true
}

func (v SimNodes1Value) Type(ctx context.Context) attr.Type {
	return SimNodes1Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SimNodes1Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"created": basetypes.Int64Type{},
		"deleted": basetypes.Int64Type{},
		"updated": basetypes.Int64Type{},
	}
}
